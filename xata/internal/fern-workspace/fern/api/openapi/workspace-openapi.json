{"openapi":"3.0.0","info":{"contact":{"name":"support@xata.io"},"description":"Xata.io Xatabases API","license":{"name":"Apache 2.0","url":"https://www.apache.org/licenses/LICENSE-2.0.html"},"title":"xata-xb","version":"1.0"},"servers":[{"description":"","url":"/"}],"paths":{"/db/{db_branch_name}":{"delete":{"description":"Delete the branch in the database and all its resources","operationId":"deleteBranch","responses":{"200":{"content":{"application/json":{"schema":{"properties":{"status":{"$ref":"#/components/schemas/MigrationStatus"}},"required":["status"],"type":"object"}}},"description":"OK"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"409":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Delete Database branch","tags":["Branch"]},"description":"This path allows interacting with a given database branch, referenced by parameter `db_branch_name`, which is expected in the format `database_name:branch_name`.","get":{"operationId":"getBranchDetails","responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/DBBranch"}}},"description":"OK"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Get branch schema and metadata","tags":["Branch"]},"parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"}],"put":{"operationId":"createBranch","parameters":[{"description":"Name of source branch to branch the new schema from","in":"query","name":"from","schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"properties":{"from":{"description":"Select the branch to fork from. Defaults to 'main'","type":"string"},"metadata":{"$ref":"#/components/schemas/BranchMetadata"}},"type":"object"}}}},"responses":{"201":{"content":{"application/json":{"schema":{"description":"","example":{"branchName":"mybranch","databaseName":"mydatabase","status":"completed"},"properties":{"branchName":{"type":"string"},"databaseName":{"minLength":1,"type":"string"},"status":{"$ref":"#/components/schemas/MigrationStatus"}},"required":["databaseName","branchName","status"],"type":"object"}}},"description":"Created","headers":{"Location":{"description":"URI to newly created resource: /db/{db_branch_name}","schema":{"format":"uri","type":"string"}}}},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"423":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Create Database branch","tags":["Branch"]},"summary":"Database Branch by Name"},"/db/{db_branch_name}/metadata":{"description":"This path allows interacting with the metadata of a specific database branch.","get":{"operationId":"getBranchMetadata","responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/BranchMetadata"}}},"description":"OK"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Get Branch Metadata","tags":["Branch"]},"parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"}],"put":{"description":"Update the branch metadata","operationId":"updateBranchMetadata","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/BranchMetadata"}}}},"responses":{"204":{"description":"No Content"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Update branch metadata","tags":["Branch"]},"summary":"Branch Metadata"},"/db/{db_branch_name}/schema/apply":{"description":"Update the branch from schema edit script.","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"}],"post":{"operationId":"applyBranchSchemaEdit","requestBody":{"content":{"application/json":{"schema":{"properties":{"edits":{"$ref":"#/components/schemas/SchemaEditScript"}},"required":["edits"],"type":"object"}}}},"responses":{"200":{"$ref":"#/components/responses/SchemaUpdateResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Apply edit script.","tags":["Migrations"]},"summary":"Update Branch schema with edit script."},"/db/{db_branch_name}/schema/compare":{"description":"Compare the branch schema with a custom provided schema.","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"}],"post":{"operationId":"compareBranchWithUserSchema","requestBody":{"content":{"application/json":{"schema":{"properties":{"branchOperations":{"items":{"$ref":"#/components/schemas/MigrationOp"},"type":"array"},"schema":{"$ref":"#/components/schemas/Schema"},"schemaOperations":{"items":{"$ref":"#/components/schemas/MigrationOp"},"type":"array"}},"required":["schema"],"type":"object"}}}},"responses":{"200":{"$ref":"#/components/responses/SchemaCompareResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Compare branch with user schema.","tags":["Migrations"]},"summary":"Compare branch with custom schema."},"/db/{db_branch_name}/schema/compare/{branch_name}":{"description":"Compare the schema of any 2 branches.","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/BranchNameParam"}],"post":{"operationId":"compareBranchSchemas","requestBody":{"content":{"application/json":{"schema":{"properties":{"sourceBranchOperations":{"items":{"$ref":"#/components/schemas/MigrationOp"},"type":"array"},"targetBranchOperations":{"items":{"$ref":"#/components/schemas/MigrationOp"},"type":"array"}},"required":["schema"],"type":"object"}}}},"responses":{"200":{"$ref":"#/components/responses/SchemaCompareResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Compare branch schemas.","tags":["Migrations"]},"summary":"Compare branch schemas."},"/db/{db_branch_name}/schema/history":{"description":"Query the branch its schema history.","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"}],"post":{"operationId":"getBranchSchemaHistory","requestBody":{"content":{"application/json":{"schema":{"properties":{"page":{"properties":{"after":{"description":"Query the next page that follow the cursor.","type":"string"},"before":{"description":"Query the previous page before the cursor.","type":"string"},"size":{"default":20,"description":"Set page size. If the size is missing it is read from the cursor. If no cursor is given xata will choose the default page size.","type":"integer"}},"type":"object"},"since":{"description":"Report only migrations that have been added since the given Migration ID.","type":"string"}},"type":"object"}}}},"responses":{"200":{"content":{"application/json":{"schema":{"properties":{"logs":{"items":{"$ref":"#/components/schemas/Commit"},"type":"array"},"meta":{"properties":{"cursor":{"description":"last record id","type":"string"},"more":{"description":"true if more records can be fetch","type":"boolean"}},"required":["cursor","more"],"type":"object"}},"required":["meta","logs"],"type":"object"}}},"description":"OK"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Query schema history.","tags":["Migrations"]},"summary":"Query schema history."},"/db/{db_branch_name}/schema/preview":{"description":"Preview the resulting branch schema when applying the edit script.","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"}],"post":{"operationId":"previewBranchSchemaEdit","requestBody":{"content":{"application/json":{"schema":{"properties":{"edits":{"$ref":"#/components/schemas/SchemaEditScript"}},"type":"object"}}}},"responses":{"200":{"content":{"application/json":{"schema":{"properties":{"original":{"$ref":"#/components/schemas/Schema"},"updated":{"$ref":"#/components/schemas/Schema"}},"required":["original","updated"],"type":"object"}}},"description":"OK"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Preview branch schema edits.","tags":["Migrations"]},"summary":"Preview branch schema edits."},"/db/{db_branch_name}/schema/push":{"description":"Apply a list of migrations to the current branch.","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"}],"post":{"description":"The `schema/push` API accepts a list of migrations to be applied to the\ncurrent branch. A list of applicable migrations can be fetched using\nthe `schema/history` API from another branch or database.\n\nThe most recent migration must be part of the list or referenced (via\n`parentID`) by the first migration in the list of migrations to be pushed.\n\nEach migration in the list has an `id`, `parentID`, and `checksum`. The\nchecksum for migrations are generated and verified by xata. The\noperation fails if any migration in the list has an invalid checksum.\n","operationId":"pushBranchMigrations","requestBody":{"content":{"application/json":{"schema":{"properties":{"migrations":{"items":{"$ref":"#/components/schemas/MigrationObject"},"type":"array"}},"required":["migrations"],"type":"object"}}}},"responses":{"200":{"$ref":"#/components/responses/SchemaUpdateResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Push migrations.","tags":["Migrations"]},"summary":"Push migrations."},"/db/{db_branch_name}/schema/update":{"description":"Update the branch schema with migration operations","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"}],"post":{"operationId":"updateBranchSchema","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Migration"}}}},"responses":{"200":{"$ref":"#/components/responses/SchemaUpdateResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Update Branch schema","tags":["Migrations"]},"summary":"Update Branch schema"},"/db/{db_branch_name}/search":{"description":"This endpoint performs full text search across an entire database branch. You can filter down to  particular\ntable by using the `tables` parameter. The `tables` parameter accepts a mixed array of strings and objects. Using a string (the table name) selects the full table. Using an object allows one to specify a filter as well. The supported filters are the same as documented for the [query endpoint](/api-reference/db/db_branch_name/tables/table_name/) with the following exceptions:\n* filters `$contains`, `$startsWith`, `$endsWith` don't work on columns of type `text`\n* filtering on columns of type `multiple` is currently unsupported\n","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"}],"post":{"description":"Run a free text search operation across the database branch.","operationId":"searchBranch","requestBody":{"content":{"application/json":{"schema":{"description":"","example":{"query":"after a long day","tables":["users",{"filter":{"author":"Abigail"},"table":"articles"}]},"properties":{"fuzziness":{"$ref":"#/components/schemas/FuzzinessExpression"},"highlight":{"$ref":"#/components/schemas/HighlightExpression"},"page":{"$ref":"#/components/schemas/SearchPageConfig"},"prefix":{"$ref":"#/components/schemas/PrefixExpression"},"query":{"description":"The query string.","minLength":1,"type":"string"},"tables":{"description":"An array with the tables in which to search. By default, all tables are included. Optionally, filters can be included that apply to each table.","items":{"oneOf":[{"type":"string"},{"additionalProperties":false,"properties":{"boosters":{"items":{"$ref":"#/components/schemas/BoosterExpression"},"type":"array"},"filter":{"$ref":"#/components/schemas/FilterExpression"},"table":{"description":"The name of the table.","type":"string"},"target":{"$ref":"#/components/schemas/TargetExpression"}},"required":["table"],"type":"object"}]},"type":"array"}},"required":["query"],"type":"object"}}}},"responses":{"200":{"$ref":"#/components/responses/SearchResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"503":{"$ref":"#/components/responses/ServiceUnavailableError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Free text search","tags":["Search and Filter"]},"summary":"Search Database"},"/db/{db_branch_name}/sql":{"description":"This endpoint performs the SQL query across the entire database branch. Set your SQL query in the parameter `query`.\n","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"}],"post":{"description":"Run an SQL query across the database branch.","operationId":"sqlQuery","requestBody":{"content":{"application/json":{"schema":{"description":"","example":{"statement":"select * from users;"},"properties":{"consistency":{"default":"strong","description":"The consistency level for this request.","enum":["strong","eventual"],"type":"string"},"params":{"description":"The query parameter list.","nullable":true,"type":"array"},"statement":{"description":"The SQL statement.","minLength":1,"type":"string"}},"required":["statement"],"type":"object"}}}},"responses":{"200":{"$ref":"#/components/responses/SQLResponse"},"201":{"$ref":"#/components/responses/SQLResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"503":{"$ref":"#/components/responses/ServiceUnavailableError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"summary":"SQL query","tags":["SQL"]},"summary":"Query database using SQL"},"/db/{db_branch_name}/stats":{"description":"This endpoint presents a number of statistics on a given database's branch.","get":{"description":"Get branch usage metrics.","operationId":"getBranchStats","responses":{"200":{"content":{"application/json":{"schema":{"properties":{"interval":{"type":"string"},"numberOfRecords":{"items":{"$ref":"#/components/schemas/MetricsDatapoint"},"type":"array"},"readLatency":{"$ref":"#/components/schemas/MetricsLatency"},"readsOverTime":{"items":{"$ref":"#/components/schemas/MetricsDatapoint"},"type":"array"},"resolution":{"type":"string"},"timestamp":{"type":"string"},"warning":{"type":"string"},"writeLatency":{"$ref":"#/components/schemas/MetricsLatency"},"writesOverTime":{"items":{"$ref":"#/components/schemas/MetricsDatapoint"},"type":"array"}},"required":["timestamp","interval","resolution"],"type":"object"}}},"description":"OK"},"400":{"$ref":"#/components/responses/SimpleError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Branch stats","tags":["Branch"]},"parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"}],"summary":"Branch Statistics"},"/db/{db_branch_name}/tables/{table_name}":{"delete":{"description":"Deletes the table with the given name.","operationId":"deleteTable","responses":{"200":{"content":{"application/json":{"schema":{"properties":{"status":{"$ref":"#/components/schemas/MigrationStatus"}},"required":["status"],"type":"object"}}},"description":"OK"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"description":"Not Found"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Delete table","tags":["Table"]},"description":"This endpoint provides a way to mutate a specific table on a database.","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"}],"patch":{"description":"Update table. Currently there is only one update operation supported: renaming the table by providing a new name.\n\nIn the example below, we rename a table from “users” to “people”:\n\n```json\n// PATCH /db/test:main/tables/users\n\n{\n  \"name\": \"people\"\n}\n```","operationId":"updateTable","requestBody":{"content":{"application/json":{"schema":{"description":"","properties":{"name":{"minLength":1,"type":"string"}},"required":["name"],"type":"object"}}},"description":""},"responses":{"200":{"$ref":"#/components/responses/SchemaUpdateResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"422":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Update table","tags":["Table"]},"put":{"description":"Creates a new table with the given name. Returns 422 if a table with the same name already exists.","operationId":"createTable","responses":{"201":{"content":{"application/json":{"schema":{"description":"","example":{"branchName":"mydb_main","status":"completed","tableName":"mytable"},"properties":{"branchName":{"type":"string"},"status":{"$ref":"#/components/schemas/MigrationStatus"},"tableName":{"minLength":1,"type":"string"}},"required":["branchName","tableName","status"],"type":"object"}}},"description":"Created","headers":{"Location":{"description":"URI to newly created resource: /db/{db_branch_name}/tables/{table_name}","schema":{"format":"uri","type":"string"}}}},"204":{"description":"No Content"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"422":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Create table","tags":["Table"]},"summary":"Database Table by Name"},"/db/{db_branch_name}/tables/{table_name}/aggregate":{"parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"}],"post":{"description":"This endpoint allows you to run aggregations (analytics) on the data from one table.\nWhile the summary endpoint is served from a transactional store and the results are strongly \nconsistent, the aggregate endpoint is served from our columnar store and the results are \nonly eventually consistent. On the other hand, the aggregate endpoint uses a \nstore that is more appropiate for analytics, makes use of approximative algorithms \n(e.g for cardinality), and is generally faster and can do more complex aggregations.\n\nFor usage, see the [API Guide](https://xata.io/docs/api-guide/aggregate).\n","operationId":"aggregateTable","requestBody":{"content":{"application/json":{"schema":{"properties":{"aggs":{"$ref":"#/components/schemas/AggExpressionMap"},"filter":{"$ref":"#/components/schemas/FilterExpression"}},"type":"object"}}}},"responses":{"200":{"$ref":"#/components/responses/AggResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Run aggregations over a table","tags":["Search and Filter"]},"summary":"Aggregate Table"},"/db/{db_branch_name}/tables/{table_name}/ask":{"description":"Ask your table a question and have Xata answer.","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"}],"post":{"description":"Ask your table a question. If the `Accept` header is set to `text/event-stream`, Xata will stream the results back as SSE's.","operationId":"askTable","requestBody":{"content":{"application/json":{"schema":{"additionalProperties":false,"description":"","properties":{"question":{"description":"The question you'd like to ask.","minLength":3,"type":"string"},"rules":{"items":{"type":"string"},"type":"array"},"search":{"additionalProperties":false,"properties":{"boosters":{"items":{"$ref":"#/components/schemas/BoosterExpression"},"type":"array"},"filter":{"$ref":"#/components/schemas/FilterExpression"},"fuzziness":{"$ref":"#/components/schemas/FuzzinessExpression"},"prefix":{"$ref":"#/components/schemas/PrefixExpression"},"target":{"$ref":"#/components/schemas/TargetExpression"}},"type":"object"},"searchType":{"default":"keyword","description":"The type of search to use. If set to `keyword` (the default), the search can be configured by passing\na `search` object with the following fields. For more details about each, see the Search endpoint documentation.\nAll fields are optional.\n  * fuzziness  - typo tolerance\n  * target - columns to search into, and weights.\n  * prefix - prefix search type.\n  * filter - pre-filter before searching.\n  * boosters - control relevancy.\nIf set to `vector`, a `vectorSearch` object must be passed, with the following parameters. For more details, see the Vector\nSearch endpoint documentation. The `column` and `contentColumn` parameters are required.\n  * column - the vector column containing the embeddings.\n  * contentColumn - the column that contains the text from which the embeddings where computed.\n  * filter - pre-filter before searching.\n","enum":["keyword","vector"],"type":"string"},"vectorSearch":{"additionalProperties":false,"properties":{"column":{"description":"The column to use for vector search. It must be of type `vector`.","type":"string"},"contentColumn":{"description":"The column containing the text for vector search. Must be of type `text`.","type":"string"},"filter":{"$ref":"#/components/schemas/FilterExpression"}},"required":["column","contentColumn"],"type":"object"}},"required":["question"],"type":"object"}}}},"responses":{"200":{"content":{"application/json":{"schema":{"properties":{"answer":{"description":"The answer to the input question","type":"string"},"sessionId":{"description":"The session ID for the chat session.","type":"string"}},"required":["answer","sessionId"],"type":"object"}},"text/event-stream":{"schema":{"properties":{"answer":{"description":"The answer to the input question","type":"string"},"records":{"description":"The IDs of the records that were used as context.","items":{"type":"string"},"type":"array"},"sessionId":{"description":"The session ID for the chat session.","type":"string"}},"required":["answer","records","sessionId"],"type":"object"}}},"description":"Response to the question"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"429":{"$ref":"#/components/responses/RateLimitError"},"503":{"description":"Unexpected Error"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Ask your table a question","tags":["Search and Filter"]},"summary":"Ask data in your table a question"},"/db/{db_branch_name}/tables/{table_name}/ask/{session_id}":{"description":"Continue a conversation with your data. This endpoint lets you continue a question started via the /ask endpoint in order to dive deeper into your context or ask clarifying questions.","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"},{"$ref":"#/components/parameters/ChatSessionIDParam"}],"post":{"description":"Ask a follow-up question. If the `Accept` header is set to `text/event-stream`, Xata will stream the results back as SSE's.","operationId":"askTableSession","requestBody":{"content":{"application/json":{"schema":{"additionalProperties":false,"properties":{"message":{"description":"The question you'd like to ask.","minLength":3,"type":"string"}},"type":"object"}}}},"responses":{"200":{"content":{"application/json":{"schema":{"properties":{"answer":{"description":"The answer to the input question","type":"string"}},"required":["answer"],"type":"object"}},"text/event-stream":{"schema":{"properties":{"answer":{"description":"The answer to the input question","type":"string"}},"required":["answer"],"type":"object"}}},"description":"Response to the question"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"429":{"$ref":"#/components/responses/RateLimitError"},"503":{"$ref":"#/components/responses/ServiceUnavailableError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Continue a conversation with your data","tags":["Search and Filter"]},"summary":"Ask follow-up questions of your data"},"/db/{db_branch_name}/tables/{table_name}/bulk":{"description":"This endpoint enables bulk operations on a given table. For now, we only allow bulk inserting.\n\nAn example bulk request looks like this:\n\n```json\n// POST https://tutorial-ng7s8c.xata.sh/db/tutorial:main/tables/users/bulk\n\n{\n  \"records\": [\n    {\n      \"email\": \"laurence@example.com\",\n      \"full_name\": \"Laurence Fishburne\",\n      \"team\": \"rec_c8hng2h26un90p8sr7k0\"\n    },\n    {\n      \"email\": \"hugo@example.com\",\n      \"full_name\": \"Hugo Weaving\",\n      \"team\": \"rec_c8hng2h26un90p8sr7k0\"\n    },\n    {\n      \"email\": \"joe@example.com\",\n      \"full_name\": \"Joe Pantoliano\",\n      \"team\": \"rec_c8hng2h26un90p8sr7k0\"\n    }\n  ]\n}\n```\nFor more details, see the [this section](/web-api/records/insert#inserting-records-in-bulk) from the tutorial.\n","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"},{"$ref":"#/components/parameters/ColumnsProjectionParam"}],"post":{"description":"Bulk insert records","operationId":"bulkInsertTableRecords","requestBody":{"content":{"application/json":{"schema":{"properties":{"records":{"items":{"$ref":"#/components/schemas/DataInputRecord"},"type":"array"}},"required":["records"],"type":"object"}}}},"responses":{"200":{"$ref":"#/components/responses/BulkInsertResponse"},"400":{"$ref":"#/components/responses/BulkError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"422":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Bulk insert records","tags":["Records"],"x-experimental":true},"summary":"Bulk Table Operations"},"/db/{db_branch_name}/tables/{table_name}/columns":{"description":"This endpoint allows working with a table's columns.","get":{"description":"Retrieves the list of table columns and their definition. This endpoint returns the column list with object columns being reported with their\nfull dot-separated path (flattened).\n","operationId":"getTableColumns","responses":{"200":{"content":{"application/json":{"schema":{"example":{"columns":[{"name":"name","type":"string"},{"name":"email","type":"email"},{"name":"settings.plan","type":"string"},{"name":"settings.dark","type":"bool"}]},"properties":{"columns":{"items":{"$ref":"#/components/schemas/Column"},"type":"array"}},"required":["columns"],"type":"object"}}},"description":"OK"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"List table columns","tags":["Table"]},"parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"}],"post":{"description":"Adds a new column to the table. The body of the request should contain the column definition.","operationId":"addTableColumn","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Column","example":{"name":"columnName","type":"string"}}}},"description":"The column definition."},"responses":{"200":{"$ref":"#/components/responses/SchemaUpdateResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Create new column","tags":["Table"]},"summary":"Table Columns"},"/db/{db_branch_name}/tables/{table_name}/columns/{column_name}":{"delete":{"description":"Deletes the specified column.","operationId":"deleteColumn","responses":{"200":{"$ref":"#/components/responses/SchemaUpdateResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Delete column","tags":["Table"]},"description":"This endpoint allows working with a single column from a given table.","get":{"description":"Get the definition of a single column.","operationId":"getColumn","responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Column","example":{"value":{"name":"settings.labels","type":"multiple"}}}}},"description":"OK"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Get column information","tags":["Table"]},"parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"},{"$ref":"#/components/parameters/ColumnNameParam"}],"patch":{"description":"Update column with partial data. Can be used for renaming the column by providing a new \"name\" field.","operationId":"updateColumn","requestBody":{"content":{"application/json":{"examples":{"Rename column":{"value":{"name":"new_name"}}},"schema":{"description":"","example":{"description":"Sample new description","name":"newName"},"properties":{"name":{"minLength":1,"type":"string"}},"required":["name"],"type":"object"}}}},"responses":{"200":{"$ref":"#/components/responses/SchemaUpdateResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Update column","tags":["Table"]},"summary":"Single Table Column"},"/db/{db_branch_name}/tables/{table_name}/data":{"description":"This endpoint enables mutating data into a given database table. To query data, please see the [query endpoint](query).\nFor a tutorial on using the Records API, see the [Record API documentation](/rest-api/intro).\n","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"},{"$ref":"#/components/parameters/ColumnsProjectionParam"}],"post":{"description":"Insert a new Record into the Table","operationId":"insertRecord","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/DataInputRecord"}}}},"responses":{"201":{"$ref":"#/components/responses/RecordUpdateResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Insert record","tags":["Records"]},"summary":"Table Data"},"/db/{db_branch_name}/tables/{table_name}/data/{record_id}":{"delete":{"operationId":"deleteRecord","responses":{"200":{"$ref":"#/components/responses/RecordResponse"},"204":{"description":"No Content"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Delete record from table","tags":["Records"]},"description":"This endpoint enables mutating a given record in a table, referenced by its ID.","get":{"description":"Retrieve record by ID","operationId":"getRecord","responses":{"200":{"$ref":"#/components/responses/RecordResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Get record by ID","tags":["Records"]},"parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"},{"$ref":"#/components/parameters/RecordIDParam"},{"$ref":"#/components/parameters/ColumnsProjectionParam"}],"patch":{"operationId":"updateRecordWithID","parameters":[{"in":"query","name":"ifVersion","schema":{"type":"integer"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/DataInputRecord"}}}},"responses":{"200":{"$ref":"#/components/responses/RecordUpdateResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"422":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Update record with ID","tags":["Records"]},"post":{"operationId":"upsertRecordWithID","parameters":[{"in":"query","name":"ifVersion","schema":{"type":"integer"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/DataInputRecord"}}}},"responses":{"200":{"$ref":"#/components/responses/RecordUpdateResponse"},"201":{"$ref":"#/components/responses/RecordUpdateResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"422":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Upsert record with ID","tags":["Records"]},"put":{"description":"By default, IDs are auto-generated when data is insterted into Xata. Sending a request to this endpoint allows us to insert a record with a pre-existing ID, bypassing the default automatic ID generation.","operationId":"insertRecordWithID","parameters":[{"in":"query","name":"createOnly","schema":{"type":"boolean"}},{"in":"query","name":"ifVersion","schema":{"type":"integer"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/DataInputRecord"}}}},"responses":{"200":{"$ref":"#/components/responses/RecordUpdateResponse"},"201":{"$ref":"#/components/responses/RecordUpdateResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"422":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Insert record with ID","tags":["Records"]},"summary":"Table Record"},"/db/{db_branch_name}/tables/{table_name}/data/{record_id}/column/{column_name}/file":{"delete":{"description":"Deletes a file referred in a file column","operationId":"deleteFile","responses":{"200":{"$ref":"#/components/responses/PutFileResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Remove the content from a file column","tags":["Files"]},"description":"File access endpoint allows upload and download of binary file content.","get":{"description":"Retrieves the file content from a file column","operationId":"getFile","responses":{"200":{"content":{"*/*":{"schema":{"format":"binary","type":"string"}}},"description":"OK"},"204":{"description":"no content"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Download content from a file column","tags":["Files"]},"parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"},{"$ref":"#/components/parameters/RecordIDParam"},{"$ref":"#/components/parameters/ColumnNameParam"}],"put":{"description":"Uploads the file content to the given file column","operationId":"putFile","requestBody":{"content":{"*/*":{"schema":{"format":"binary","type":"string"}}}},"responses":{"200":{"$ref":"#/components/responses/PutFileResponse"},"201":{"$ref":"#/components/responses/PutFileResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"422":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Upload content to a file column","tags":["Files"]},"summary":"File column access"},"/db/{db_branch_name}/tables/{table_name}/data/{record_id}/column/{column_name}/file/{file_id}":{"delete":{"description":"Deletes an item from an file array column given the file ID","operationId":"deleteFileItem","responses":{"200":{"$ref":"#/components/responses/PutFileResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Delete an item from a file array","tags":["Files"]},"description":"File array access endpoint allows upload, download and remove of file items.","get":{"description":"Retrieves file content from an array by file ID","operationId":"getFileItem","responses":{"200":{"content":{"*/*":{"schema":{"format":"binary","type":"string"}}},"description":"OK"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Download content from a file item in a file array column","tags":["Files"]},"parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"},{"$ref":"#/components/parameters/RecordIDParam"},{"$ref":"#/components/parameters/ColumnNameParam"},{"$ref":"#/components/parameters/FileItemIDParam"}],"put":{"description":"Uploads the file content to an array given the file ID","operationId":"putFileItem","requestBody":{"content":{"*/*":{"schema":{"format":"binary","type":"string"}}}},"responses":{"200":{"$ref":"#/components/responses/PutFileResponse"},"201":{"$ref":"#/components/responses/PutFileResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"422":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Upload or update the content of a file item in a file array column","tags":["Files"]},"summary":"File array access"},"/db/{db_branch_name}/tables/{table_name}/query":{"description":"This endpoint serves data from a given table, inside a specific database's branch.\nFor a tutorial on using the Records API, see the [Record API documentation](/rest-api/intro).\n","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"}],"post":{"description":"The Query Table API can be used to retrieve all records in a table.\nThe API support filtering, sorting, selecting a subset of columns, and pagination.\n\nThe overall structure of the request looks like this:\n\n```json\n// POST /db/\u003cdbname\u003e:\u003cbranch\u003e/tables/\u003ctable\u003e/query\n{\n  \"columns\": [...],\n  \"filter\": {\n    \"$all\": [...],\n    \"$any\": [...]\n    ...\n  },\n  \"sort\": {\n    \"multiple\": [...]\n    ...\n  },\n  \"page\": {\n    ...\n  }\n}\n```\n\nFor usage, see also the [API Guide](https://xata.io/docs/api-guide/get).\n\n### Column selection\n\nIf the `columns` array is not specified, all columns are included. For link\nfields, only the ID column of the linked records is included in the response.\n\nIf the `columns` array is specified, only the selected and internal\ncolumns `id` and `xata` are included. The `*` wildcard can be used to\nselect all columns.\n\nFor objects and link fields, if the column name of the object is specified, we\ninclude all of its sub-keys. If only some sub-keys are specified (via dotted\nnotation, e.g. `\"settings.plan\"` ), then only those sub-keys from the object\nare included.\n\nBy the way of example, assuming two tables like this:\n\n```json {\"truncate\": true}\n{\n  \"tables\": [\n    {\n      \"name\": \"teams\",\n      \"columns\": [\n        {\n          \"name\": \"name\",\n          \"type\": \"string\"\n        },\n        {\n          \"name\": \"owner\",\n          \"type\": \"link\",\n          \"link\": {\n            \"table\": \"users\"\n          }\n        },\n        {\n          \"name\": \"foundedDate\",\n          \"type\": \"datetime\"\n        },\n      ]\n    },\n    {\n      \"name\": \"users\",\n      \"columns\": [\n        {\n          \"name\": \"email\",\n          \"type\": \"email\"\n        },\n        {\n          \"name\": \"full_name\",\n          \"type\": \"string\"\n        },\n        {\n          \"name\": \"address\",\n          \"type\": \"object\",\n          \"columns\": [\n            {\n              \"name\": \"street\",\n              \"type\": \"string\"\n            },\n            {\n              \"name\": \"number\",\n              \"type\": \"int\"\n            },\n            {\n              \"name\": \"zipcode\",\n              \"type\": \"int\"\n            }\n          ]\n        },\n        {\n          \"name\": \"team\",\n          \"type\": \"link\",\n          \"link\": {\n            \"table\": \"teams\"\n          }\n        }\n      ]\n    }\n  ]\n}\n```\n\nA query like this:\n\n```json\nPOST /db/\u003cdbname\u003e:\u003cbranch\u003e/tables/\u003ctable\u003e/query\n{\n  \"columns\": [\n    \"name\",\n    \"address.*\"\n  ]\n}\n```\n\nreturns objects like:\n\n```json\n{\n  \"name\": \"Kilian\",\n  \"address\": {\n    \"street\": \"New street\",\n    \"number\": 41,\n    \"zipcode\": 10407\n  }\n}\n```\n\nwhile a query like this:\n\n```json\nPOST /db/\u003cdbname\u003e:\u003cbranch\u003e/tables/\u003ctable\u003e/query\n{\n  \"columns\": [\n    \"name\",\n    \"address.street\"\n  ]\n}\n```\n\nreturns objects like:\n\n```json\n{\n  \"id\": \"id1\"\n  \"xata\": {\n    \"version\": 0\n  }\n  \"name\": \"Kilian\",\n  \"address\": {\n    \"street\": \"New street\"\n  }\n}\n```\n\nIf you want to return all columns from the main table and selected columns from the linked table, you can do it like this:\n\n```json\n{\n  \"columns\": [\"*\", \"team.name\"]\n}\n```\n\nThe `\"*\"` in the above means all columns, including columns of objects. This returns data like:\n\n```json\n{\n  \"id\": \"id1\"\n  \"xata\": {\n    \"version\": 0\n  }\n  \"name\": \"Kilian\",\n  \"email\": \"kilian@gmail.com\",\n  \"address\": {\n    \"street\": \"New street\",\n    \"number\": 41,\n    \"zipcode\": 10407\n  },\n  \"team\": {\n    \"id\": \"XX\",\n    \"xata\": {\n      \"version\": 0\n    },\n    \"name\": \"first team\"\n  }\n}\n```\n\nIf you want all columns of the linked table, you can do:\n\n```json\n{\n  \"columns\": [\"*\", \"team.*\"]\n}\n```\n\nThis returns, for example:\n\n```json\n{\n  \"id\": \"id1\"\n  \"xata\": {\n    \"version\": 0\n  }\n  \"name\": \"Kilian\",\n  \"email\": \"kilian@gmail.com\",\n  \"address\": {\n    \"street\": \"New street\",\n    \"number\": 41,\n    \"zipcode\": 10407\n  },\n  \"team\": {\n    \"id\": \"XX\",\n    \"xata\": {\n      \"version\": 0\n    },\n    \"name\": \"first team\",\n    \"code\": \"A1\",\n    \"foundedDate\": \"2020-03-04T10:43:54.32Z\"\n  }\n}\n```\n\n### Filtering\n\nThere are two types of operators:\n\n- Operators that work on a single column: `$is`, `$contains`, `$pattern`,\n  `$includes`, `$gt`, etc.\n- Control operators that combine multiple conditions: `$any`, `$all`, `$not` ,\n  `$none`, etc.\n\nAll operators start with an `$` to differentiate them from column names\n(which are not allowed to start with a dollar sign).\n\n#### Exact matching and control operators\n\nFilter by one column:\n\n```json\n{\n  \"filter\": {\n    \"\u003ccolumn_name\u003e\": \"value\"\n  }\n}\n```\n\nThis is equivalent to using the `$is` operator:\n\n```json\n{\n  \"filter\": {\n    \"\u003ccolumn_name\u003e\": {\n      \"$is\": \"value\"\n    }\n  }\n}\n```\n\nFor example:\n\n```json\n{\n  \"filter\": {\n    \"name\": \"r2\"\n  }\n}\n```\n\nOr:\n\n```json\n{\n  \"filter\": {\n    \"name\": {\n      \"$is\": \"r2\"\n    }\n  }\n}\n```\n\nFor objects, both dots and nested versions work:\n\n```json\n{\n  \"filter\": {\n    \"settings.plan\": \"free\"\n  }\n}\n```\n\n```json\n{\n  \"filter\": {\n    \"settings\": {\n      \"plan\": \"free\"\n    }\n  }\n}\n```\n\nIf you want to OR together multiple values, you can use the `$any` operator with an array of values:\n\n```json\n{\n  \"filter\": {\n    \"settings.plan\": { \"$any\": [\"free\", \"paid\"] }\n  }\n}\n```\n\nIf you specify multiple columns in the same filter, they are logically AND'ed together:\n\n```json\n{\n  \"filter\": {\n    \"settings.dark\": true,\n    \"settings.plan\": \"free\"\n  }\n}\n```\n\nThe above matches if both conditions are met.\n\nTo be more explicit about it, you can use `$all` or `$any`:\n\n```json\n{\n  \"filter\": {\n    \"$any\": {\n      \"settings.dark\": true,\n      \"settings.plan\": \"free\"\n    }\n  }\n}\n```\n\nThe `$all` and `$any` operators can also receive an array of objects, which allows for repeating column names:\n\n```json\n{\n  \"filter\": {\n    \"$any\": [\n      {\n        \"name\": \"r1\"\n      },\n      {\n        \"name\": \"r2\"\n      }\n    ]\n  }\n}\n```\n\nYou can check for a value being not-null with `$exists`:\n\n```json\n{\n  \"filter\": {\n    \"$exists\": \"settings\"\n  }\n}\n```\n\nThis can be combined with `$all` or `$any` :\n\n```json\n{\n  \"filter\": {\n    \"$all\": [\n      {\n        \"$exists\": \"settings\"\n      },\n      {\n        \"$exists\": \"name\"\n      }\n    ]\n  }\n}\n```\n\nOr you can use the inverse operator `$notExists`:\n\n```json\n{\n  \"filter\": {\n    \"$notExists\": \"settings\"\n  }\n}\n```\n\n#### Partial match\n\n`$contains` is the simplest operator for partial matching. Note that `$contains` operator can\ncause performance issues at scale, because indices cannot be used.\n\n```json\n{\n  \"filter\": {\n    \"\u003ccolumn_name\u003e\": {\n      \"$contains\": \"value\"\n    }\n  }\n}\n```\n\nWildcards are supported via the `$pattern` operator:\n\n```json\n{\n  \"filter\": {\n    \"\u003ccolumn_name\u003e\": {\n      \"$pattern\": \"v*alu?\"\n    }\n  }\n}\n```\n\nThe `$pattern` operator accepts two wildcard characters:\n* `*` matches zero or more characters\n* `?` matches exactly one character\n\nIf you want to match a string that contains a wildcard character, you can escape them using a backslash (`\\`). You can escape a backslash by usign another backslash.\n\nYou can also use the `$endsWith` and `$startsWith` operators:\n\n```json\n{\n  \"filter\": {\n    \"\u003ccolumn_name\u003e\": {\n      \"$endsWith\": \".gz\"\n    },\n    \"\u003ccolumn_name\u003e\": {\n      \"$startsWith\": \"tmp-\"\n    }\n  }\n}\n```\n\n#### Numeric or datetime ranges\n\n```json\n{\n  \"filter\": {\n    \"\u003ccolumn_name\u003e\": {\n      \"$ge\": 0,\n      \"$lt\": 100\n    }\n  }\n}\n```\nDate ranges support the same operators, with the date using the format defined in\n[RFC 3339](https://www.rfc-editor.org/rfc/rfc3339):\n```json\n{\n  \"filter\": {\n    \"\u003ccolumn_name\u003e\": {\n      \"$gt\": \"2019-10-12T07:20:50.52Z\",\n      \"$lt\": \"2021-10-12T07:20:50.52Z\"\n    }\n  }\n}\n```\nThe supported operators are `$gt`, `$lt`, `$ge`, `$le`.\n\n#### Negations\n\nA general `$not` operator can inverse any operation.\n\n```json\n{\n  \"filter\": {\n    \"$not\": {\n      \"\u003ccolumn_name1\u003e\": \"value1\",\n      \"\u003ccolumn_name2\u003e\": \"value1\"\n    }\n  }\n}\n```\n\nNote: in the above the two condition are AND together, so this does (NOT ( ...\nAND ...))\n\nOr more complex:\n\n```json\n{\n  \"filter\": {\n    \"$not\": {\n      \"$any\": [\n        {\n          \"\u003ccolumn_name1\u003e\": \"value1\"\n        },\n        {\n          \"$all\": [\n            {\n              \"\u003ccolumn_name2\u003e\": \"value2\"\n            },\n            {\n              \"\u003ccolumn_name3\u003e\": \"value3\"\n            }\n          ]\n        }\n      ]\n    }\n  }\n}\n```\n\nThe `$not: { $any: {}}` can be shorted using the `$none` operator:\n\n```json\n{\n  \"filter\": {\n    \"$none\": {\n      \"\u003ccolumn_name1\u003e\": \"value1\",\n      \"\u003ccolumn_name2\u003e\": \"value1\"\n    }\n  }\n}\n```\n\nIn addition, you can use operators like `$isNot` or `$notExists` to simplify expressions:\n\n```json\n{\n  \"filter\": {\n    \"\u003ccolumn_name\u003e\": {\n      \"$isNot\": \"2019-10-12T07:20:50.52Z\"\n    }\n  }\n}\n```\n\n#### Working with arrays\n\nTo test that an array contains a value, use `$includesAny`.\n\n```json\n{\n  \"filter\": {\n    \"\u003carray_name\u003e\": {\n      \"$includesAny\": \"value\"\n    }\n  }\n}\n```\n\n##### `includesAny`\n\nThe `$includesAny` operator accepts a custom predicate that will check if\nany value in the array column matches the predicate. The `$includes` operator is a\nsynonym for the `$includesAny` operator.\n\nFor example a complex predicate can include\nthe `$all` , `$contains` and `$endsWith` operators:\n\n```json\n{\n  \"filter\": {\n    \"\u003carray name\u003e\": {\n      \"$includes\": {\n        \"$all\": [\n          { \"$contains\": \"label\" },\n          { \"$not\": { \"$endsWith\": \"-debug\" } }\n        ]\n      }\n    }\n  }\n}\n```\n\n##### `includesNone`\n\nThe `$includesNone` operator succeeds if no array item matches the\npredicate.\n\n```json\n{\n  \"filter\": {\n    \"settings.labels\": {\n      \"$includesNone\": [{ \"$contains\": \"label\" }]\n    }\n  }\n}\n```\nThe above matches if none of the array values contain the string \"label\".\n\n##### `includesAll`\n\nThe `$includesAll` operator succeeds if all array items match the\npredicate.\n\nHere is an example of using the `$includesAll` operator:\n\n```json\n{\n  \"filter\": {\n    \"settings.labels\": {\n      \"$includesAll\": [{ \"$contains\": \"label\" }]\n    }\n  }\n}\n```\n\nThe above matches if all array values contain the string \"label\".\n\n### Sorting\n\nSorting by one element:\n\n```json\nPOST /db/demo:main/tables/table/query\n{\n  \"sort\": {\n    \"index\": \"asc\"\n  }\n}\n```\n\nor descendently:\n\n```json\nPOST /db/demo:main/tables/table/query\n{\n  \"sort\": {\n    \"index\": \"desc\"\n  }\n}\n```\n\nSorting by multiple fields:\n\n```json\nPOST /db/demo:main/tables/table/query\n{\n  \"sort\": [\n    {\n      \"index\": \"desc\"\n    },\n    {\n      \"createdAt\": \"desc\"\n    }\n  ]\n}\n```\n\nIt is also possible to sort results randomly:\n\n```json\nPOST /db/demo:main/tables/table/query\n{\n  \"sort\": {\n    \"*\": \"random\"\n  }\n}\n```\n\nNote that a random sort does not apply to a specific column, hence the special column name `\"*\"`.\n\nA random sort can be combined with an ascending or descending sort on a specific column:\n\n```json\nPOST /db/demo:main/tables/table/query\n{\n  \"sort\": [\n    {\n      \"name\": \"desc\"\n    },\n    {\n      \"*\": \"random\"\n    }\n  ]\n}\n```\n\nThis will sort on the `name` column, breaking ties randomly.\n\n### Pagination\n\nWe offer cursor pagination and offset pagination. The cursor pagination method can be used for sequential scrolling with unrestricted depth. The offset pagination can be used to skip pages and is limited to 1000 records.\n\nExample of cursor pagination:\n\n```json\nPOST /db/demo:main/tables/table/query\n{\n  \"page\": {\n    \"after\":\"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD\"\n  }\n}\n```\n\nIn the above example, the value of the `page.after` parameter is the cursor returned by the previous query. A sample response is shown below:\n\n```json\n{\n  \"meta\": {\n    \"page\": {\n      \"cursor\": \"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD\",\n      \"more\": true\n    }\n  },\n  \"records\": [...]\n}\n```\n\nThe `page` object might contain the follow keys, in addition to `size` and `offset` that were introduced before:\n\n- `after`: Return the next page 'after' the current cursor\n- `before`: Return the previous page 'before' the current cursor.\n- `start`: Resets the given cursor position to the beginning of the query result set. \nWill return the first N records from the query result, where N is the `page.size` parameter. \n- `end`: Resets the give cursor position to the end for the query result set. \nReturns the last N records from the query result, where N is the `page.size` parameter.\n\nThe request will fail if an invalid cursor value is given to `page.before`,\n`page.after`, `page.start` , or `page.end`. No other cursor setting can be\nused if `page.start` or `page.end` is set in a query.\n\nIf both `page.before` and `page.after` parameters are present we treat the\nrequest as a range query. The range query will return all entries after\n`page.after`, but before `page.before`, up to `page.size` or the maximum\npage size. This query requires both cursors to use the same filters and sort\nsettings, plus we require `page.after \u003c page.before`. The range query returns\na new cursor. If the range encompass multiple pages the next page in the range\ncan be queried by update `page.after` to the returned cursor while keeping the\n`page.before` cursor from the first range query.\n\nThe `filter` , `columns`, `sort` , and `page.size` configuration will be\nencoded with the cursor. The pagination request will be invalid if\n`filter` or `sort` is set. The columns returned and page size can be changed\nanytime by passing the `columns` or `page.size` settings to the next query.\n\nIn the following example of size + offset pagination we retrieve the third page of up to 100 results:\n\n```json\nPOST /db/demo:main/tables/table/query\n{\n  \"page\": {\n    \"size\": 100,\n    \"offset\": 200\n  }\n}\n```\n\nThe `page.size` parameter represents the maximum number of records returned by this query. It has a default value of 20 and a maximum value of 200.\nThe `page.offset` parameter represents the number of matching records to skip. It has a default value of 0 and a maximum value of 800.\n\nCursor pagination also works in combination with offset pagination. For example, starting from a specific cursor position, using a page size of 200 and an offset of 800, you can skip up to 5 pages of 200 records forwards or backwards from the cursor's position:\n\n```json\nPOST /db/demo:main/tables/table/query\n{\n  \"page\": {\n    \"size\": 200,\n    \"offset\": 800,\n    \"after\": \"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD\"\n  }\n}\n```\n\n**Special cursors:**\n\n- `page.after=end`: Result points past the last entry. The list of records\n  returned is empty, but `page.meta.cursor` will include a cursor that can be\n  used to \"tail\" the table from the end waiting for new data to be inserted.\n- `page.before=end`: This cursor returns the last page.\n- `page.start=$cursor`: Start at the beginning of the result set of the $cursor query. This is equivalent to querying the\n  first page without a cursor but applying `filter` and `sort` . Yet the `page.start`\n  cursor can be convenient at times as user code does not need to remember the\n  filter, sort, columns or page size configuration. All these information are\n  read from the cursor.\n- `page.end=$cursor`: Move to the end of the result set of the $cursor query. This is equivalent to querying the\n  last page with `page.before=end`, `filter`, and `sort` . Yet the\n  `page.end` cursor can be more convenient at times as user code does not\n  need to remember the filter, sort, columns or page size configuration. All\n  these information are read from the cursor.\n\nWhen using special cursors like `page.after=\"end\"` or `page.before=\"end\"`, we\nstill allow `filter` and `sort` to be set.\n\nExample of getting the last page:\n\n```json\nPOST /db/demo:main/tables/table/query\n{\n  \"page\": {\n    \"size\": 10,\n    \"before\": \"end\"\n  }\n}\n```\n","operationId":"queryTable","requestBody":{"content":{"application/json":{"schema":{"properties":{"columns":{"$ref":"#/components/schemas/QueryColumnsProjection"},"consistency":{"default":"strong","description":"The consistency level for this request.","enum":["strong","eventual"],"type":"string"},"filter":{"$ref":"#/components/schemas/FilterExpression"},"page":{"$ref":"#/components/schemas/PageConfig"},"sort":{"$ref":"#/components/schemas/SortExpression"}},"type":"object"}}}},"responses":{"200":{"$ref":"#/components/responses/QueryResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"503":{"$ref":"#/components/responses/ServiceUnavailableError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Query table","tags":["Search and Filter"]},"summary":"Query Table Data"},"/db/{db_branch_name}/tables/{table_name}/schema":{"description":"This endpoint enables reading or updating the schema of a given table.","get":{"operationId":"getTableSchema","responses":{"200":{"content":{"application/json":{"schema":{"properties":{"columns":{"items":{"$ref":"#/components/schemas/Column"},"type":"array"}},"required":["columns"],"type":"object"}}},"description":"OK"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Get table schema","tags":["Table"]},"parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"}],"put":{"operationId":"setTableSchema","requestBody":{"content":{"application/json":{"schema":{"properties":{"columns":{"items":{"$ref":"#/components/schemas/Column"},"type":"array"}},"required":["columns"],"type":"object"}}}},"responses":{"200":{"$ref":"#/components/responses/SchemaUpdateResponse"},"204":{"description":"No Content"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"409":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Update table schema","tags":["Table"]},"summary":"Table Schema"},"/db/{db_branch_name}/tables/{table_name}/search":{"description":"This endpoint performs full text search in a particular table.\n","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"}],"post":{"description":"Run a free text search operation in a particular table.\n\nThe endpoint accepts a `query` parameter that is used for the free text search and a set of structured filters (via the `filter` parameter) that are applied before the search. The `filter` parameter uses the same syntax as the [query endpoint](/api-reference/db/db_branch_name/tables/table_name/) with the following exceptions:\n* filters `$contains`, `$startsWith`, `$endsWith` don't work on columns of type `text`\n* filtering on columns of type `multiple` is currently unsupported\n","operationId":"searchTable","requestBody":{"content":{"application/json":{"schema":{"description":"","example":{"filter":{"firstName":"Abigail"},"query":"after a long day"},"properties":{"boosters":{"items":{"$ref":"#/components/schemas/BoosterExpression"},"type":"array"},"filter":{"$ref":"#/components/schemas/FilterExpression"},"fuzziness":{"$ref":"#/components/schemas/FuzzinessExpression"},"highlight":{"$ref":"#/components/schemas/HighlightExpression"},"page":{"$ref":"#/components/schemas/SearchPageConfig"},"prefix":{"$ref":"#/components/schemas/PrefixExpression"},"query":{"description":"The query string.","minLength":1,"type":"string"},"target":{"$ref":"#/components/schemas/TargetExpression"}},"required":["query"],"type":"object"}}}},"responses":{"200":{"$ref":"#/components/responses/SearchResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Free text search in a table","tags":["Search and Filter"]},"summary":"Search Table"},"/db/{db_branch_name}/tables/{table_name}/summarize":{"description":"This endpoint summarizes from your database. It comes with a range\nof functions to help perform calculations on the data you have stored\nin your tables\n","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"}],"post":{"description":"This endpoint allows you to (optionally) define groups, and then to run\ncalculations on the values in each group. This is most helpful when \nyou'd like to understand the data you have in your database.\n\nA group is a combination of unique values. If you create a group for \n`sold_by`, `product_name`, we will return one row for every combination \nof `sold_by` and `product_name` you have in your database. When you \nwant to calculate statistics, you define these groups and ask Xata to \ncalculate data on each group.\n\n**Some questions you can ask of your data:**\n\nHow many records do I have in this table?\n- Set `columns: []` as we we want data from the entire table, so we ask\nfor no groups.\n- Set `summaries: {\"total\": {\"count\": \"*\"}}` in order to see the count \nof all records. We use `count: *` here we'd like to know the total \namount of rows; ignoring whether they are `null` or not.\n\nWhat are the top total sales for each product in July 2022 and sold \nmore than 10 units?\n- Set `filter: {soldAt: {\n  \"$ge\": \"2022-07-01T00:00:00.000Z\", \n  \"$lt\": \"2022-08-01T00:00:00.000Z\"}\n}` \nin order to limit the result set to sales recorded in July 2022.\n- Set `columns: [product_name]` as we'd like to run calculations on \neach unique product name in our table. Setting `columns` like this will \nproduce one row per unique product name.\n- Set `summaries: {\"total_sales\": {\"count\": \"product_name\"}}` as we'd \nlike to create a field called \"total_sales\" for each group. This field \nwill count all rows in each group with non-null product names.\n- Set `sort: [{\"total_sales\": \"desc\"}]` in order to bring the rows with \nthe highest total_sales field to the top.\n- Set `summariesFilter: {\"total_sales\": {\"$ge\": 10}}` to only send back data \nwith greater than or equal to 10 units.\n\n`columns`: tells Xata how to create each group. If you add `product_id` \nwe will create a new group for every unique `product_id`.\n\n`summaries`: tells Xata which calculations to run on each group. Xata\ncurrently supports count, min, max, sum, average.\n\n`sort`: tells Xata in which order you'd like to see results. You may \nsort by fields specified in `columns` as well as the summary names \ndefined in `summaries`.\n\nnote: Sorting on summarized values can be slower on very large tables; \nthis will impact your rate limit significantly more than other queries. \nTry use `filter` to reduce the amount of data being processed in order \nto reduce impact on your limits.\n\n`summariesFilter`: tells Xata how to filter the results of a summary. \nIt has the same syntax as `filter`, however, by using `summariesFilter`\nyou may also filter on the results of a query.\n\nnote: This is a much slower to use than `filter`. We recommend using \n`filter` wherever possible and `summariesFilter` when it's not \npossible to use `filter`.\n\n`page.size`: tells Xata how many records to return. If unspecified, Xata\nwill return the default size.\n","operationId":"summarizeTable","requestBody":{"content":{"application/json":{"schema":{"properties":{"columns":{"$ref":"#/components/schemas/ColumnsProjection"},"consistency":{"default":"strong","description":"The consistency level for this request.","enum":["strong","eventual"],"type":"string"},"filter":{"$ref":"#/components/schemas/FilterExpression"},"page":{"properties":{"size":{"default":20,"description":"The number of records returned by summarize. If the amount of data you have exceeds this, or you have\nmore complex reporting requirements, we recommend that you use the aggregate endpoint instead.\n","maximum":1000,"minimum":1,"type":"integer"}},"type":"object"},"sort":{"$ref":"#/components/schemas/SortExpression"},"summaries":{"$ref":"#/components/schemas/SummaryExpressionList"},"summariesFilter":{"$ref":"#/components/schemas/FilterExpression"}},"type":"object"}}}},"responses":{"200":{"$ref":"#/components/responses/SummarizeResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Summarize table","tags":["Search and Filter"]},"summary":"Summarize Table Data"},"/db/{db_branch_name}/tables/{table_name}/vectorSearch":{"description":"This endpoint can be used to perform vector-based similarity searches.\n","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"},{"$ref":"#/components/parameters/TableNameParam"}],"post":{"description":"This endpoint can be used to perform vector-based similarity searches in a table. \nIt can be used for implementing semantic search and product recommendation. To use this\nendpoint, you need a column of type vector. The input vector must have the same\ndimension as the vector column.\n","operationId":"vectorSearchTable","requestBody":{"content":{"application/json":{"schema":{"additionalProperties":false,"description":"","properties":{"column":{"description":"The vector column in which to search. It must be of type `vector`.","type":"string"},"filter":{"$ref":"#/components/schemas/FilterExpression"},"queryVector":{"description":"The vector to search for similarities. Must have the same dimension as\nthe vector column used.\n","items":{"type":"number"},"type":"array"},"similarityFunction":{"default":"cosineSimilarity","description":"The function used to measure the distance between two points. Can be one of:\n`cosineSimilarity`, `l1`, `l2`. The default is `cosineSimilarity`.\n","type":"string"},"size":{"default":10,"description":"Number of results to return.","maximum":100,"minimum":1,"type":"integer"}},"required":["queryVector","column"],"type":"object"}}}},"responses":{"200":{"$ref":"#/components/responses/SearchResponse"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Vector similarity search in a table","tags":["Search and Filter"]},"summary":"Vector similarity search"},"/db/{db_branch_name}/transaction":{"description":"Executes multiple operations together as one. This allows you to run a number of \noperations that succeed as a single group; or fail with no changes to your database.\n","parameters":[{"$ref":"#/components/parameters/DBBranchNameParam"}],"post":{"operationId":"branchTransaction","requestBody":{"content":{"application/json":{"schema":{"properties":{"operations":{"items":{"$ref":"#/components/schemas/TransactionOperation"},"type":"array"}},"required":["operations"],"type":"object"}}}},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/TransactionSuccess"}}},"description":"Returns the results of a successful transaction."},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/TransactionFailure"}}},"description":"Returns errors from a failed transaction."},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"429":{"$ref":"#/components/responses/RateLimitError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Execute a transaction on a branch","tags":["Records"]},"summary":"Execute a transaction on a branch"},"/dbs/{db_name}":{"description":"Given a parameter `db_name`, this path allows interacting with a specific database on Xata. Below are a number of operations that can be performed on a given database.","get":{"description":"List all available Branches","operationId":"getBranchList","responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ListBranchesResponse"}}},"description":"OK"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"$ref":"#/components/responses/SimpleError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"List branches","tags":["Branch"]},"parameters":[{"$ref":"#/components/parameters/DBNameParam"}],"summary":"Single Database"},"/dbs/{db_name}/gitBranches":{"delete":{"description":"Removes an entry from the mapping of git branches to Xata branches. The name of the git branch must be passed as a query parameter. If the git branch is not found, the endpoint returns a 404 status code.\n\nExample request:\n\n```json\n// DELETE https://tutorial-ng7s8c.xata.sh/dbs/demo/gitBranches?gitBranch=fix%2Fbug123\n```\n","operationId":"removeGitBranchesEntry","parameters":[{"description":"The Git Branch to remove from the mapping","in":"query","name":"gitBranch","required":true,"schema":{"type":"string"}}],"responses":{"204":{"description":"OK"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"404":{"description":"The git branch was not found in the mapping"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Unlink a git branch to a Xata branch","tags":["Branch"]},"description":"This path allows managing the mapping between git and Xata branches, which is used by the `/dbs/{db_name}/resolveBranch` endpoint to resolve git branches to the associated Xata branches.\n","get":{"description":"Lists all the git branches in the mapping, and their associated Xata branches.\n\nExample response:\n\n```json\n{\n  \"mappings\": [\n      {\n        \"gitBranch\": \"main\",\n        \"xataBranch\": \"main\"\n      },\n      {\n        \"gitBranch\": \"gitBranch1\",\n        \"xataBranch\": \"xataBranch1\"\n      }\n      {\n        \"gitBranch\": \"xataBranch2\",\n        \"xataBranch\": \"xataBranch2\"\n      }\n  ]\n}\n```\n","operationId":"getGitBranchesMapping","responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ListGitBranchesResponse"}}},"description":"OK"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"List git branches mapping","tags":["Branch"]},"parameters":[{"$ref":"#/components/parameters/DBNameParam"}],"post":{"description":"Adds an entry to the mapping of git branches to Xata branches. The git branch and the Xata branch must be present in the body of the request. If the Xata branch doesn't exist, a 400 error is returned.\n\nIf the git branch is already present in the mapping, the old entry is overwritten, and a warning message is included in the response. If the git branch is added and didn't exist before, the response code is 204. If the git branch existed and it was overwritten, the response code is 201.\n\nExample request:\n\n```json\n// POST https://tutorial-ng7s8c.xata.sh/dbs/demo/gitBranches\n{\n  \"gitBranch\": \"fix/bug123\",\n  \"xataBranch\": \"fix_bug\"\n}\n```\n","operationId":"addGitBranchesEntry","requestBody":{"content":{"application/json":{"schema":{"properties":{"gitBranch":{"description":"The name of the Git branch.","type":"string"},"xataBranch":{"$ref":"#/components/schemas/BranchName","description":"The name of the Xata branch."}},"required":["gitBranch","xataBranch"],"type":"object"}}}},"responses":{"201":{"content":{"application/json":{"schema":{"example":{"warning":"Git branch [fix/bug123] was already present in the mapping and was overwritten."},"properties":{"warning":{"description":"Warning message","type":"string"}},"type":"object"}}},"description":"Operation was successful with warnings"},"204":{"description":"Operation was successful without warnings"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Link a git branch to a Xata branch","tags":["Branch"]},"summary":"Mapping of git to Xata branches"},"/dbs/{db_name}/resolveBranch":{"description":"This endpoint is typically used by the Xata SDKs to resolve the correct branch to use in a particular situation. The main input is the git branch.","get":{"description":"In order to resolve the database branch, the following algorithm is used:\n* if the `gitBranch` was provided and is found in the [git branches mapping](/api-reference/dbs/db_name/gitBranches), the associated Xata branch is returned\n* else, if a Xata branch with the exact same name as `gitBranch` exists, return it\n* else, if `fallbackBranch` is provided and a branch with that name exists, return it\n* else, return the default branch of the DB (`main` or the first branch)\n\nExample call:\n\n```json\n// GET https://tutorial-ng7s8c.xata.sh/dbs/demo/dbs/demo/resolveBranch?gitBranch=test\u0026fallbackBranch=tsg\n```\n\nExample response:\n\n```json\n{\n  \"branch\": \"main\",\n  \"reason\": {\n    \"code\": \"DEFAULT_BRANCH\",\n    \"message\": \"Default branch for this database (main)\"\n  }\n}\n```\n","operationId":"resolveBranch","parameters":[{"description":"The Git Branch","in":"query","name":"gitBranch","schema":{"type":"string"}},{"description":"Default branch to fallback to","in":"query","name":"fallbackBranch","schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"example":{"branch":"main","reason":{"code":"DEFAULT_BRANCH","message":"Default branch for this database (main)"}},"properties":{"branch":{"type":"string"},"reason":{"properties":{"code":{"enum":["FOUND_IN_MAPPING","BRANCH_EXISTS","FALLBACK_BRANCH","DEFAULT_BRANCH"],"type":"string"},"message":{"type":"string"}},"required":["code","message"],"type":"object"}},"required":["branch","reason"],"type":"object"}}},"description":"OK"},"400":{"$ref":"#/components/responses/BadRequestError"},"401":{"$ref":"#/components/responses/AuthError"},"5XX":{"description":"Unexpected Error"},"default":{"description":"Unexpected Error"}},"security":[{"bearerAuth":[]}],"summary":"Resolve a Git Branch to a Xata branch","tags":["Branch"]},"parameters":[{"$ref":"#/components/parameters/DBNameParam"}],"summary":"Resolve the branch to use"}},"components":{"parameters":{"BranchNameParam":{"description":"The Database Name","in":"path","name":"branch_name","required":true,"schema":{"$ref":"#/components/schemas/BranchName"}},"ChatSessionIDParam":{"in":"path","name":"session_id","required":true,"schema":{"maxLength":36,"minLength":36,"title":"SessionID","type":"string"}},"ColumnNameParam":{"description":"The Column name","in":"path","name":"column_name","required":true,"schema":{"$ref":"#/components/schemas/ColumnName"}},"ColumnsProjectionParam":{"description":"Column filters","explode":false,"in":"query","name":"columns","required":false,"schema":{"$ref":"#/components/schemas/ColumnsProjection"}},"DBBranchNameParam":{"description":"The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n","in":"path","name":"db_branch_name","required":true,"schema":{"$ref":"#/components/schemas/DBBranchName"}},"DBNameParam":{"description":"The Database Name","in":"path","name":"db_name","required":true,"schema":{"$ref":"#/components/schemas/DBName"}},"FileAccessIDParam":{"description":"The File Access Identifier","in":"path","name":"file_id","required":true,"schema":{"$ref":"#/components/schemas/FileAccessID"}},"FileItemIDParam":{"description":"The File Identifier","in":"path","name":"file_id","required":true,"schema":{"$ref":"#/components/schemas/FileItemID"}},"FileSignatureParam":{"description":"File access signature","explode":false,"in":"query","name":"verify","required":false,"schema":{"$ref":"#/components/schemas/FileSignature"}},"RecordIDParam":{"description":"The Record name","in":"path","name":"record_id","required":true,"schema":{"$ref":"#/components/schemas/RecordID"}},"TableNameParam":{"description":"The Table name","in":"path","name":"table_name","required":true,"schema":{"$ref":"#/components/schemas/TableName"}}},"responses":{"AggResponse":{"content":{"application/json":{"schema":{"example":{"aggs":{"dailyUniqueUsers":{"values":[{"$count":321,"$key":"2022-02-22T22:22:22Z","uniqueUsers":134},{"$count":202,"$key":"2022-02-23T22:22:22Z","uniqueUsers":90}]}}},"properties":{"aggs":{"additionalProperties":{"$ref":"#/components/schemas/AggResponse"},"type":"object"}},"type":"object"}}},"description":"OK"},"AuthError":{"content":{"application/json":{"schema":{"example":{"message":"invalid API key"},"properties":{"id":{"type":"string"},"message":{"type":"string"}},"required":["message"],"type":"object"}}},"description":"Authentication Error"},"BadRequestError":{"content":{"application/json":{"schema":{"properties":{"id":{"type":"string"},"message":{"type":"string"}},"required":["message"],"type":"object"}}},"description":"Bad Request"},"BranchMigrationPlan":{"content":{"application/json":{"schema":{"properties":{"migration":{"$ref":"#/components/schemas/BranchMigration"},"version":{"type":"integer"}},"required":["version","migration"],"type":"object"}}},"description":"Example response"},"BulkError":{"content":{"application/json":{"schema":{"properties":{"errors":{"items":{"properties":{"message":{"type":"string"},"status":{"type":"integer"}},"type":"object"},"type":"array"}},"required":["errors"],"type":"object"}}},"description":"Response with multiple errors of the bulk execution"},"BulkInsertResponse":{"content":{"application/json":{"schema":{"oneOf":[{"properties":{"recordIDs":{"items":{"type":"string"},"type":"array"}},"required":["recordIDs"],"type":"object"},{"properties":{"records":{"items":{"$ref":"#/components/schemas/Record"},"type":"array"}},"required":["records"],"type":"object"}]}}},"description":"OK"},"PutFileResponse":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/FileResponse"}}},"description":"OK"},"QueryResponse":{"content":{"application/json":{"schema":{"properties":{"meta":{"$ref":"#/components/schemas/RecordsMetadata"},"records":{"items":{"$ref":"#/components/schemas/Record"},"type":"array"}},"required":["records","meta"],"type":"object"}}},"description":"OK"},"RateLimitError":{"content":{"application/json":{"schema":{"properties":{"id":{"type":"string"},"message":{"type":"string"}},"required":["message"],"type":"object"}},"text/event-stream":{"schema":{"type":"string"}}},"description":"Rate limit exceeded"},"RecordResponse":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Record"}}},"description":"Table Record Reponse"},"RecordUpdateResponse":{"content":{"application/json":{"schema":{"anyOf":[{"$ref":"#/components/schemas/Record"},{"properties":{"id":{"type":"string"},"xata":{"properties":{"createdAt":{"type":"string"},"updatedAt":{"type":"string"},"version":{"type":"integer"}},"required":["version","createdAt","updatedAt"],"type":"object"}},"required":["id","xata"],"type":"object"}]}}},"description":"Record ID and metadata"},"SQLResponse":{"content":{"application/json":{"schema":{"properties":{"columns":{"allOf":[{"type":"object"}],"description":"Name of the column and its PostgreSQL type"},"records":{"items":{"$ref":"#/components/schemas/SQLRecord"},"type":"array"},"total":{"description":"Number of selected columns","type":"integer"},"warning":{"type":"string"}},"type":"object"}}},"description":"OK"},"SchemaCompareResponse":{"content":{"application/json":{"schema":{"properties":{"edits":{"$ref":"#/components/schemas/SchemaEditScript"},"source":{"$ref":"#/components/schemas/Schema"},"target":{"$ref":"#/components/schemas/Schema"}},"required":["source","target","edits"],"type":"object"}}},"description":"Schema comparison response."},"SchemaUpdateResponse":{"content":{"application/json":{"examples":{"example-1":{"value":{"migrationID":"mig_c7m19ilcefoebpqj12p0","parentMigrationID":"mig_c7m19ilcefoebpqj4312","status":"completed"}}},"schema":{"properties":{"migrationID":{"minLength":1,"type":"string"},"parentMigrationID":{"type":"string"},"status":{"$ref":"#/components/schemas/MigrationStatus"}},"required":["migrationID","parentMigrationID","status"],"type":"object"}}},"description":"Schema migration response with ID and migration status."},"SearchResponse":{"content":{"application/json":{"schema":{"properties":{"records":{"items":{"$ref":"#/components/schemas/Record"},"type":"array"},"totalCount":{"description":"The total count of records matched. It will be accurately returned up to 10000 records.","type":"integer"},"warning":{"type":"string"}},"required":["records","totalCount"],"type":"object"}}},"description":"OK"},"ServiceUnavailableError":{"content":{"application/json":{"schema":{"properties":{"id":{"type":"string"},"message":{"type":"string"}},"required":["message"],"type":"object"}}},"description":"ServiceUnavailable","headers":{"Retry-After":{"schema":{"description":"Number of seconds to wait after retrying the operation","type":"string"}}}},"SimpleError":{"content":{"application/json":{"schema":{"properties":{"id":{"type":"string"},"message":{"type":"string"}},"required":["message"],"type":"object"}}},"description":"Example response"},"SummarizeResponse":{"content":{"application/json":{"schema":{"properties":{"summaries":{"items":{"type":"object"},"type":"array"}},"required":["summaries"],"type":"object"}}},"description":"OK"}},"schemas":{"AggExpression":{"description":"The description of a single aggregation operation. It is an object with only one key-value pair.\nThe key represents the aggregation type, while the value is an object with the configuration of\nthe aggregation.\n","oneOf":[{"additionalProperties":false,"properties":{"count":{"$ref":"#/components/schemas/CountAgg"}},"type":"object"},{"additionalProperties":false,"properties":{"sum":{"$ref":"#/components/schemas/SumAgg"}},"type":"object"},{"additionalProperties":false,"properties":{"max":{"$ref":"#/components/schemas/MaxAgg"}},"type":"object"},{"additionalProperties":false,"properties":{"min":{"$ref":"#/components/schemas/MinAgg"}},"type":"object"},{"additionalProperties":false,"properties":{"average":{"$ref":"#/components/schemas/AverageAgg"}},"type":"object"},{"additionalProperties":false,"properties":{"percentiles":{"$ref":"#/components/schemas/PercentilesAgg"}},"type":"object"},{"additionalProperties":false,"properties":{"uniqueCount":{"$ref":"#/components/schemas/UniqueCountAgg"}},"type":"object"},{"additionalProperties":false,"properties":{"dateHistogram":{"$ref":"#/components/schemas/DateHistogramAgg"}},"type":"object"},{"additionalProperties":false,"properties":{"topValues":{"$ref":"#/components/schemas/TopValuesAgg"}},"type":"object"},{"additionalProperties":false,"properties":{"numericHistogram":{"$ref":"#/components/schemas/NumericHistogramAgg"}},"type":"object"}]},"AggExpressionMap":{"additionalProperties":{"$ref":"#/components/schemas/AggExpression"},"description":"The description of the aggregations you wish to receive.\n","example":{"dailyActiveUsers":{"dateHistogram":{"aggs":{"uniqueUsers":{"uniqueCount":{"column":"userID"}}},"column":"date","interval":"1d"}},"totalCount":{"count":"*"}},"type":"object"},"AggResponse":{"oneOf":[{"nullable":true,"type":"number"},{"properties":{"values":{"oneOf":[{"items":{"additionalProperties":{"$ref":"#/components/schemas/AggResponse"},"properties":{"$count":{"type":"integer"},"$key":{"oneOf":[{"type":"string"},{"type":"number"}]}},"required":["$key","$count"],"type":"object"},"type":"array"},{"additionalProperties":{"type":"number"},"type":"object"}]}},"required":["values"],"type":"object"}]},"AverageAgg":{"additionalProperties":false,"description":"The average of the numeric values in a particular column.","properties":{"column":{"description":"The column on which to compute the average. Must be a numeric type.","type":"string"}},"required":["column"],"type":"object"},"BoosterExpression":{"description":"Booster Expression","oneOf":[{"additionalProperties":false,"properties":{"valueBooster":{"$ref":"#/components/schemas/ValueBooster"}},"type":"object"},{"additionalProperties":false,"properties":{"numericBooster":{"$ref":"#/components/schemas/NumericBooster"}},"type":"object"},{"additionalProperties":false,"properties":{"dateBooster":{"$ref":"#/components/schemas/DateBooster"}},"type":"object"}]},"Branch":{"additionalProperties":false,"properties":{"createdAt":{"$ref":"#/components/schemas/DateTime"},"name":{"type":"string"}},"required":["name","createdAt"],"type":"object"},"BranchMetadata":{"description":"","example":{"branch":"feature-login","labels":["epic-100"],"repository":"github.com/my/repository","stage":"testing"},"properties":{"branch":{"$ref":"#/components/schemas/BranchName"},"labels":{"items":{"type":"string"},"type":"array"},"repository":{"minLength":1,"type":"string"},"stage":{"minLength":1,"type":"string"}},"type":"object"},"BranchMigration":{"properties":{"createdAt":{"$ref":"#/components/schemas/DateTime"},"id":{"type":"string"},"lastGitRevision":{"type":"string"},"localChanges":{"type":"boolean"},"newTableOrder":{"items":{"type":"string"},"type":"array"},"newTables":{"additionalProperties":{"$ref":"#/components/schemas/Table"},"type":"object"},"parentID":{"type":"string"},"removedTables":{"items":{"type":"string"},"type":"array"},"renamedTables":{"items":{"$ref":"#/components/schemas/TableRename"},"type":"array"},"status":{"type":"string"},"tableMigrations":{"additionalProperties":{"$ref":"#/components/schemas/TableMigration"},"type":"object"},"title":{"type":"string"}},"required":["status","localChanges","newTableOrder"],"title":"Migration","type":"object"},"BranchName":{"maxLength":255,"minLength":1,"pattern":"[a-zA-Z0-9_\\-~]+","title":"BranchName","type":"string"},"BranchOp":{"properties":{"createdAt":{"$ref":"#/components/schemas/DateTime"},"id":{"type":"string"},"message":{"type":"string"},"migration":{"$ref":"#/components/schemas/Commit"},"modifiedAt":{"$ref":"#/components/schemas/DateTime"},"parentID":{"type":"string"},"status":{"$ref":"#/components/schemas/MigrationStatus"},"title":{"type":"string"}},"required":["id","status","createdAt"],"type":"object"},"BranchWithCopyID":{"properties":{"branchName":{"$ref":"#/components/schemas/BranchName"},"copyID":{"type":"string"},"dbBranchID":{"type":"string"}},"required":["branchName","dbBranchID","copyID"],"title":"BranchWithCopyID","type":"object"},"Column":{"properties":{"columns":{"items":{"$ref":"#/components/schemas/Column"},"type":"array"},"defaultValue":{"type":"string"},"file":{"$ref":"#/components/schemas/ColumnFile"},"fileMap":{"$ref":"#/components/schemas/ColumnFile"},"link":{"$ref":"#/components/schemas/ColumnLink"},"name":{"type":"string"},"notNull":{"type":"boolean"},"type":{"enum":["bool","int","float","string","text","email","multiple","link","object","datetime","vector","fileMap","file","json"],"type":"string"},"unique":{"type":"boolean"},"vector":{"$ref":"#/components/schemas/ColumnVector"}},"required":["name","type"],"title":"Column","type":"object"},"ColumnFile":{"additionalProperties":false,"properties":{"defaultPublicAccess":{"type":"boolean"}},"type":"object"},"ColumnLink":{"properties":{"table":{"type":"string"}},"required":["table"],"type":"object"},"ColumnMigration":{"properties":{"new":{"$ref":"#/components/schemas/Column"},"old":{"$ref":"#/components/schemas/Column"}},"required":["old","new"],"title":"ColumnMigration","type":"object"},"ColumnName":{"pattern":"[a-zA-Z0-9_\\-~\\.]+","title":"ColumnName","type":"string"},"ColumnOpAdd":{"properties":{"column":{"$ref":"#/components/schemas/Column"},"table":{"type":"string"}},"required":["table","column"],"type":"object"},"ColumnOpRemove":{"properties":{"column":{"type":"string"},"table":{"type":"string"}},"required":["table","column"],"type":"object"},"ColumnOpRename":{"properties":{"newName":{"type":"string"},"oldName":{"type":"string"},"table":{"type":"string"}},"required":["table","oldName","newName"],"type":"object"},"ColumnVector":{"additionalProperties":false,"properties":{"dimension":{"maximum":10000,"minimum":2,"type":"integer"}},"required":["dimension"],"type":"object"},"ColumnsProjection":{"example":["name","email","created_at"],"items":{"type":"string"},"type":"array"},"Commit":{"properties":{"checksum":{"type":"string"},"createdAt":{"$ref":"#/components/schemas/DateTime"},"id":{"type":"string"},"mergeParentID":{"type":"string"},"message":{"type":"string"},"operations":{"items":{"$ref":"#/components/schemas/MigrationOp"},"type":"array"},"parentID":{"type":"string"},"title":{"type":"string"}},"required":["operations","id","createdAt","checksum"],"type":"object"},"CountAgg":{"description":"Count the number of records with an optional filter.","oneOf":[{"additionalProperties":false,"properties":{"filter":{"$ref":"#/components/schemas/FilterExpression"}},"type":"object"},{"description":"Use this form to count all records without any filter.","enum":["*"],"type":"string"}]},"DBBranch":{"properties":{"branchName":{"$ref":"#/components/schemas/BranchName"},"createdAt":{"$ref":"#/components/schemas/DateTime"},"databaseName":{"$ref":"#/components/schemas/DBName"},"id":{"type":"string"},"lastMigrationID":{"type":"string"},"metadata":{"$ref":"#/components/schemas/BranchMetadata"},"schema":{"$ref":"#/components/schemas/Schema"},"startedFrom":{"$ref":"#/components/schemas/StartedFromMetadata"},"version":{"type":"number"}},"required":["databaseName","branchName","createdAt","id","version","lastMigrationID","schema"],"title":"DBBranch","type":"object"},"DBBranchName":{"description":"The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n","maxLength":511,"minLength":1,"pattern":"[a-zA-Z0-9_\\-~]+:[a-zA-Z0-9_\\-~]+","title":"Tuple of database and branch name","type":"string"},"DBName":{"maxLength":255,"minLength":1,"pattern":"[a-zA-Z0-9_\\-~]+","title":"DBName","type":"string"},"DataInputRecord":{"additionalProperties":{"anyOf":[{"$ref":"#/components/schemas/RecordID"},{"type":"string"},{"type":"boolean"},{"type":"number"},{"items":{"type":"string"},"type":"array"},{"items":{"type":"number"},"type":"array"},{"$ref":"#/components/schemas/DateTime"},{"$ref":"#/components/schemas/InputFileArray"},{"$ref":"#/components/schemas/InputFile"}],"nullable":true},"description":"Xata input record","type":"object"},"DateBooster":{"additionalProperties":false,"description":"Boost records based on the value of a datetime column. It is configured via \"origin\", \"scale\", and \"decay\". The further away from the \"origin\",\nthe more the score is decayed. The decay function uses an exponential function. For example if origin is \"now\", and scale is 10 days and decay is 0.5, it\nshould be interpreted as: a record with a date 10 days before/after origin will be boosted 2 times less than a record with the date at origin.\nThe result of the exponential function is a boost between 0 and 1. The \"factor\" allows you to control how impactful this boost is, by multiplying it with a given value.\n","properties":{"column":{"description":"The column in which to look for the value.","type":"string"},"decay":{"description":"The decay factor to expect at \"scale\" distance from the \"origin\".","type":"number"},"factor":{"description":"The factor with which to multiply the added boost.","minimum":0,"type":"number"},"ifMatchesFilter":{"$ref":"#/components/schemas/FilterExpression","description":"Only apply this booster to the records for which the provided filter matches.\n"},"origin":{"description":"The datetime (formatted as RFC3339) from where to apply the score decay function. The maximum boost will be applied for records with values at this time.\nIf it is not specified, the current date and time is used.\n","type":"string"},"scale":{"description":"The duration at which distance from origin the score is decayed with factor, using an exponential function. It is formatted as number + units, for example: `5d`, `20m`, `10s`.\n","pattern":"^(\\d+)(d|h|m|s|ms)$","type":"string"}},"required":["column","scale","decay"]},"DateHistogramAgg":{"additionalProperties":false,"description":"Split data into buckets by a datetime column. Accepts sub-aggregations for each bucket.\n","properties":{"aggs":{"$ref":"#/components/schemas/AggExpressionMap"},"calendarInterval":{"description":"The calendar-aware interval to use when bucketing. Possible values are: `minute`,\n`hour`, `day`, `week`, `month`, `quarter`, `year`.\n","enum":["minute","hour","day","week","month","quarter","year"],"type":"string"},"column":{"description":"The column to use for bucketing. Must be of type datetime.","type":"string"},"interval":{"description":"The fixed interval to use when bucketing. \nIt is formatted as number + units, for example: `5d`, `20m`, `10s`.\n","pattern":"^(\\d+)(d|h|m|s|ms)$","type":"string"},"timezone":{"description":"The timezone to use for bucketing. By default, UTC is assumed.\nThe accepted format is as an ISO 8601 UTC offset. For example: `+01:00` or\n`-08:00`.\n","pattern":"^[+-][01]\\d:[0-5]\\d$","type":"string"}},"required":["column"],"type":"object"},"DateTime":{"format":"date-time","title":"DateTime","type":"string"},"FileAccessID":{"description":"File identifier in access URLs","maxLength":296,"minLength":88,"pattern":"[a-v0-9=]+","title":"FileID","type":"string"},"FileItemID":{"description":"Unique file identifier","maxLength":255,"minLength":1,"pattern":"[a-zA-Z0-9_-~:]+","title":"FileID","type":"string"},"FileName":{"description":"File name","maxLength":1024,"minLength":0,"pattern":"[0-9a-zA-Z!\\-_\\.\\*'\\(\\)]*","type":"string"},"FileResponse":{"description":"File metadata","properties":{"attributes":{"type":"object"},"id":{"$ref":"#/components/schemas/FileItemID"},"mediaType":{"$ref":"#/components/schemas/MediaType"},"name":{"$ref":"#/components/schemas/FileName"},"size":{"format":"int64","type":"integer"},"version":{"format":"int64","type":"integer"}},"required":["name","mediaType","size","version"],"type":"object"},"FileSignature":{"description":"File signature","type":"string"},"FilterColumn":{"anyOf":[{"$ref":"#/components/schemas/FilterColumnIncludes"},{"$ref":"#/components/schemas/FilterPredicate"},{"$ref":"#/components/schemas/FilterList"}]},"FilterColumnIncludes":{"additionalProperties":false,"maxProperties":1,"minProperties":1,"properties":{"$includes":{"$ref":"#/components/schemas/FilterPredicate"},"$includesAll":{"$ref":"#/components/schemas/FilterPredicate"},"$includesAny":{"$ref":"#/components/schemas/FilterPredicate"},"$includesNone":{"$ref":"#/components/schemas/FilterPredicate"}},"type":"object"},"FilterExpression":{"additionalProperties":{"$ref":"#/components/schemas/FilterColumn"},"minProperties":1,"properties":{"$all":{"$ref":"#/components/schemas/FilterList"},"$any":{"$ref":"#/components/schemas/FilterList"},"$exists":{"type":"string"},"$existsNot":{"type":"string"},"$none":{"$ref":"#/components/schemas/FilterList"},"$not":{"$ref":"#/components/schemas/FilterList"}},"type":"object"},"FilterList":{"oneOf":[{"$ref":"#/components/schemas/FilterExpression"},{"items":{"$ref":"#/components/schemas/FilterExpression"},"type":"array"}]},"FilterPredicate":{"oneOf":[{"$ref":"#/components/schemas/FilterValue"},{"items":{"$ref":"#/components/schemas/FilterPredicate"},"minLength":1,"type":"array"},{"$ref":"#/components/schemas/FilterPredicateOp"},{"$ref":"#/components/schemas/FilterPredicateRangeOp"}]},"FilterPredicateOp":{"additionalProperties":false,"maxProperties":1,"minProperties":1,"properties":{"$all":{"oneOf":[{"items":{"$ref":"#/components/schemas/FilterPredicate"},"type":"array"}]},"$any":{"oneOf":[{"items":{"$ref":"#/components/schemas/FilterPredicate"},"type":"array"}]},"$contains":{"type":"string"},"$endsWith":{"type":"string"},"$ge":{"$ref":"#/components/schemas/FilterRangeValue"},"$gt":{"$ref":"#/components/schemas/FilterRangeValue"},"$iContains":{"type":"string"},"$iPattern":{"type":"string"},"$is":{"oneOf":[{"$ref":"#/components/schemas/FilterValue"},{"items":{"$ref":"#/components/schemas/FilterValue"},"type":"array"}]},"$isNot":{"oneOf":[{"$ref":"#/components/schemas/FilterValue"},{"items":{"$ref":"#/components/schemas/FilterValue"},"type":"array"}]},"$le":{"$ref":"#/components/schemas/FilterRangeValue"},"$lt":{"$ref":"#/components/schemas/FilterRangeValue"},"$none":{"oneOf":[{"$ref":"#/components/schemas/FilterPredicate"},{"items":{"$ref":"#/components/schemas/FilterPredicate"},"type":"array"}]},"$not":{"oneOf":[{"$ref":"#/components/schemas/FilterPredicate"},{"items":{"$ref":"#/components/schemas/FilterPredicate"},"type":"array"}]},"$pattern":{"type":"string"},"$startsWith":{"type":"string"}},"type":"object"},"FilterPredicateRangeOp":{"additionalProperties":false,"maxProperties":2,"minProperties":2,"properties":{"$ge":{"$ref":"#/components/schemas/FilterRangeValue"},"$gt":{"$ref":"#/components/schemas/FilterRangeValue"},"$le":{"$ref":"#/components/schemas/FilterRangeValue"},"$lt":{"$ref":"#/components/schemas/FilterRangeValue"}},"type":"object"},"FilterRangeValue":{"oneOf":[{"type":"number"},{"type":"string"}]},"FilterValue":{"oneOf":[{"type":"number"},{"type":"string"},{"type":"boolean"}]},"FuzzinessExpression":{"default":1,"description":"Maximum [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) for the search terms. The Levenshtein\ndistance is the number of one character changes needed to make two strings equal. The default is 1, meaning that single\ncharacter typos per word are tolerated by search. You can set it to 0 to remove the typo tolerance or set it to 2\nto allow two typos in a word.\n","maximum":2,"minimum":0,"type":"integer"},"HighlightExpression":{"additionalProperties":false,"properties":{"enabled":{"description":"Set to `false` to disable highlighting. By default it is `true`.\n","type":"boolean"},"encodeHTML":{"description":"Set to `false` to disable HTML encoding in highlight snippets. By default it is `true`.\n","type":"boolean"}},"type":"object"},"InputFile":{"additionalProperties":false,"description":"Object representing a file","properties":{"base64Content":{"description":"Base64 encoded content","maxLength":20971520,"type":"string"},"enablePublicUrl":{"description":"Enable public access to the file","type":"boolean"},"mediaType":{"$ref":"#/components/schemas/MediaType"},"name":{"$ref":"#/components/schemas/FileName"},"signedUrlTimeout":{"description":"Time to live for signed URLs","type":"integer"}},"required":["name"],"type":"object"},"InputFileArray":{"description":"Array of file entries","items":{"$ref":"#/components/schemas/InputFileEntry"},"maxItems":50,"type":"array"},"InputFileEntry":{"additionalProperties":false,"description":"Object representing a file in an array","properties":{"base64Content":{"description":"Base64 encoded content","maxLength":20971520,"type":"string"},"enablePublicUrl":{"description":"Enable public access to the file","type":"boolean"},"id":{"$ref":"#/components/schemas/FileItemID"},"mediaType":{"$ref":"#/components/schemas/MediaType"},"name":{"$ref":"#/components/schemas/FileName"},"signedUrlTimeout":{"description":"Time to live for signed URLs","type":"integer"}}},"ListBranchesResponse":{"additionalProperties":false,"properties":{"branches":{"items":{"$ref":"#/components/schemas/Branch"},"type":"array"},"databaseName":{"type":"string"}},"required":["databaseName","branches"],"type":"object"},"ListGitBranchesResponse":{"properties":{"mapping":{"items":{"properties":{"gitBranch":{"type":"string"},"xataBranch":{"type":"string"}},"required":["gitBranch","xataBranch"],"type":"object"},"type":"array"}},"required":["mapping"],"type":"object"},"MaxAgg":{"additionalProperties":false,"description":"The max of the numeric values in a particular column.","properties":{"column":{"description":"The column on which to compute the max. Must be a numeric type.","type":"string"}},"required":["column"],"type":"object"},"MediaType":{"description":"Media type","maxLength":255,"minLength":3,"pattern":"^\\w+/[-+.\\w]+$","type":"string"},"MetricsDatapoint":{"properties":{"timestamp":{"type":"string"},"value":{"type":"integer"}},"required":["timestamp","value"],"title":"Datapoint","type":"object"},"MetricsLatency":{"properties":{"p50":{"items":{"$ref":"#/components/schemas/MetricsDatapoint"},"type":"array"},"p90":{"items":{"$ref":"#/components/schemas/MetricsDatapoint"},"type":"array"}},"title":"MetricsLatency","type":"object"},"Migration":{"description":"Branch schema migration.","properties":{"operations":{"items":{"$ref":"#/components/schemas/MigrationOp"},"type":"array"},"parentID":{"type":"string"}},"required":["operations"],"type":"object"},"MigrationColumnOp":{"oneOf":[{"additionalProperties":false,"properties":{"addColumn":{"$ref":"#/components/schemas/ColumnOpAdd"}},"required":["addColumn"],"type":"object"},{"additionalProperties":false,"properties":{"removeColumn":{"$ref":"#/components/schemas/ColumnOpRemove"}},"required":["removeColumn"],"type":"object"},{"additionalProperties":false,"properties":{"renameColumn":{"$ref":"#/components/schemas/ColumnOpRename"}},"required":["renameColumn"],"type":"object"}]},"MigrationObject":{"properties":{"checksum":{"type":"string"},"id":{"type":"string"},"message":{"type":"string"},"operations":{"items":{"$ref":"#/components/schemas/MigrationOp"},"type":"array"},"parentID":{"type":"string"},"title":{"type":"string"}},"required":["operations","id","checksum"],"type":"object"},"MigrationOp":{"description":"Branch schema migration operations.","oneOf":[{"$ref":"#/components/schemas/MigrationTableOp"},{"$ref":"#/components/schemas/MigrationColumnOp"}]},"MigrationRequest":{"additionalProperties":false,"properties":{"body":{"description":"The migration request body with detailed description.","type":"string"},"closedAt":{"$ref":"#/components/schemas/DateTime","description":"Timestamp when the migration request was closed."},"createdAt":{"$ref":"#/components/schemas/DateTime","description":"Migration request creation timestamp."},"mergedAt":{"$ref":"#/components/schemas/DateTime","description":"Timestamp when the migration request was merged."},"modifiedAt":{"$ref":"#/components/schemas/DateTime","description":"Last modified timestamp."},"number":{"$ref":"#/components/schemas/MigrationRequestNumber"},"source":{"description":"Name of the source branch.","type":"string"},"status":{"enum":["open","closed","merging","merged","failed"],"type":"string"},"target":{"description":"Name of the target branch.","type":"string"},"title":{"description":"The migration request title.","type":"string"}},"type":"object"},"MigrationRequestNumber":{"description":"The migration request number.","minimum":0,"type":"integer"},"MigrationStatus":{"enum":["completed","pending","failed"],"type":"string"},"MigrationTableOp":{"oneOf":[{"additionalProperties":false,"properties":{"addTable":{"$ref":"#/components/schemas/TableOpAdd"}},"required":["addTable"],"type":"object"},{"additionalProperties":false,"properties":{"removeTable":{"$ref":"#/components/schemas/TableOpRemove"}},"required":["removeTable"],"type":"object"},{"additionalProperties":false,"properties":{"renameTable":{"$ref":"#/components/schemas/TableOpRename"}},"required":["renameTable"],"type":"object"}]},"MinAgg":{"additionalProperties":false,"description":"The min of the numeric values in a particular column.","properties":{"column":{"description":"The column on which to compute the min. Must be a numeric type.","type":"string"}},"required":["column"],"type":"object"},"NumericBooster":{"additionalProperties":false,"description":"Boost records based on the value of a numeric column.","properties":{"column":{"description":"The column in which to look for the value.","type":"string"},"factor":{"description":"The factor with which to multiply the value of the column before adding it to the item score.","type":"number"},"ifMatchesFilter":{"$ref":"#/components/schemas/FilterExpression","description":"Only apply this booster to the records for which the provided filter matches.\n"},"modifier":{"description":"Modifier to be applied to the column value, before being multiplied with the factor. The possible values are:\n  - none (default).\n  - log: common logarithm (base 10)\n  - log1p: add 1 then take the common logarithm. This ensures that the value is positive if the\n    value is between 0 and 1.\n  - ln: natural logarithm (base e)\n  - ln1p: add 1 then take the natural logarithm. This ensures that the value is positive if the\n    value is between 0 and 1.\n  - square: raise the value to the power of two.\n  - sqrt: take the square root of the value.\n  - reciprocal: reciprocate the value (if the value is `x`, the reciprocal is `1/x`).\n","enum":["none","log","log1p","ln","ln1p","square","sqrt","reciprocal"],"type":"string"}},"required":["column","factor"],"type":"object"},"NumericHistogramAgg":{"additionalProperties":false,"description":"Split data into buckets by dynamic numeric ranges. Accepts sub-aggregations for each bucket.\n","properties":{"aggs":{"$ref":"#/components/schemas/AggExpressionMap"},"column":{"description":"The column to use for bucketing. Must be of numeric type.","type":"string"},"interval":{"description":"The numeric interval to use for bucketing. The resulting buckets will be ranges \nwith this value as size.\n","minimum":0,"type":"number"},"offset":{"default":0,"description":"By default the bucket keys start with 0 and then continue in `interval` steps. The bucket\nboundaries can be shifted by using the offset option. For example, if the `interval` is 100,\nbut you prefer the bucket boundaries to be `[50, 150), [150, 250), etc.`, you can set `offset` \nto 50.\n","type":"number"}},"required":["column","interval"]},"PageConfig":{"description":"Pagination settings.","properties":{"after":{"description":"Query the next page that follow the cursor.","type":"string"},"before":{"description":"Query the previous page before the cursor.","type":"string"},"end":{"description":"Query the last page from the cursor.","type":"string"},"offset":{"default":0,"description":"Use offset to skip entries. To skip pages set offset to a multiple of size.","type":"integer"},"size":{"default":20,"description":"Set page size. If the size is missing it is read from the cursor. If no cursor is given Xata will choose the default page size.","type":"integer"},"start":{"description":"Query the first page from the cursor.","type":"string"}},"title":"PageConfig","type":"object"},"PercentilesAgg":{"additionalProperties":false,"description":"Calculate given percentiles of the numeric values in a particular column.","properties":{"column":{"description":"The column on which to compute the average. Must be a numeric type.","type":"string"},"percentiles":{"items":{"type":"number"},"type":"array"}},"required":["column","percentiles"],"type":"object"},"PrefixExpression":{"description":"If the prefix type is set to \"disabled\" (the default), the search only matches full words. If the prefix type is set to \"phrase\", the search will return results that match prefixes of the search phrase.\n","enum":["phrase","disabled"],"type":"string"},"ProjectionConfig":{"description":"A structured projection that allows for some configuration.","properties":{"as":{"description":"An alias for the projected field, this is how it will be returned in the response.","type":"string"},"columns":{"$ref":"#/components/schemas/QueryColumnsProjection"},"limit":{"default":20,"type":"integer"},"name":{"description":"The name of the column to project or a reverse link specification, see [API Guide](https://xata.io/docs/concepts/data-model#links-and-relations).","type":"string"},"offset":{"default":0,"type":"integer"},"sort":{"$ref":"#/components/schemas/SortExpression"}},"type":"object"},"QueryColumnsProjection":{"items":{"oneOf":[{"type":"string"}]},"type":"array"},"Record":{"allOf":[{"$ref":"#/components/schemas/RecordMeta"},{"additionalProperties":true,"type":"object"}],"description":"Xata Table Record","title":"Record"},"RecordID":{"maxLength":255,"minLength":1,"pattern":"[a-zA-Z0-9_-~:]+","title":"RecordID","type":"string"},"RecordMeta":{"description":"Xata Table Record Metadata","properties":{"id":{"$ref":"#/components/schemas/RecordID"},"xata":{"properties":{"createdAt":{"description":"The time when the record was created.","type":"string"},"highlight":{"additionalProperties":{"oneOf":[{"items":{"type":"string"},"type":"array"},{"additionalProperties":true,"type":"object"}]},"description":"Highlights of the record. This is used by the search APIs to indicate which fields and parts of the fields have matched the search.","type":"object"},"score":{"description":"The record's relevancy score. This is returned by the search APIs.","type":"number"},"table":{"description":"The record's table name. APIs that return records from multiple tables will set this field accordingly.","type":"string"},"updatedAt":{"description":"The time when the record was last updated.","type":"string"},"version":{"description":"The record's version. Can be used for optimistic concurrency control.","type":"integer"},"warnings":{"description":"Encoding/Decoding errors","items":{"type":"string"},"type":"array"}},"required":["version"],"type":"object"}},"required":["id","xata"],"title":"RecordMeta","type":"object"},"RecordsMetadata":{"description":"Records metadata","properties":{"page":{"properties":{"cursor":{"description":"last record id","type":"string"},"more":{"description":"true if more records can be fetched","type":"boolean"},"size":{"description":"the number of records returned per page","type":"number"}},"required":["cursor","more","size"],"type":"object"}},"required":["page"],"type":"object"},"RevLink":{"properties":{"column":{"type":"string"},"table":{"type":"string"}},"required":["table","column"],"title":"RevLink","type":"object"},"SQLRecord":{"allOf":[{"additionalProperties":true,"type":"object"}],"description":"Xata Table SQL Record","title":"SQL Record"},"Schema":{"properties":{"tables":{"items":{"$ref":"#/components/schemas/Table"},"type":"array"},"tablesOrder":{"items":{"type":"string"},"type":"array"}},"required":["tables"],"title":"Schema","type":"object"},"SchemaEditScript":{"properties":{"operations":{"items":{"$ref":"#/components/schemas/MigrationOp"},"type":"array"},"sourceMigrationID":{"type":"string"},"targetMigrationID":{"type":"string"}},"required":["operations"],"title":"SchemaEditScript","type":"object"},"SearchPageConfig":{"description":"Pagination settings for the search endpoints.","properties":{"offset":{"default":0,"description":"Use offset to skip entries. To skip pages set offset to a multiple of size.","maximum":800,"type":"integer"},"size":{"default":25,"description":"Set page size.","maximum":200,"type":"integer"}},"title":"SearchPageConfig"},"SortExpression":{"oneOf":[{"items":{"type":"string"},"type":"array"},{"additionalProperties":{"$ref":"#/components/schemas/SortOrder"},"type":"object"},{"items":{"additionalProperties":{"$ref":"#/components/schemas/SortOrder"},"type":"object"},"type":"array"}],"title":"SortExpression"},"SortOrder":{"enum":["asc","desc","random"],"title":"SortOrder","type":"string"},"StartedFromMetadata":{"properties":{"branchName":{"$ref":"#/components/schemas/BranchName"},"dbBranchID":{"type":"string"},"migrationID":{"type":"string"}},"required":["branchName","dbBranchID","migrationID"],"title":"StartedFromMetadata","type":"object"},"SumAgg":{"additionalProperties":false,"description":"The sum of the numeric values in a particular column.","properties":{"column":{"description":"The column on which to compute the sum. Must be a numeric type.","type":"string"}},"required":["column"],"type":"object"},"SummaryExpression":{"description":"A summary expression is the description of a single summary operation. It consists of a single\nkey representing the operation, and a value representing the column to be operated on.\n\nThe column being summarized cannot be an internal column (id, xata.*), nor the base of\nan object, i.e. if `settings` is an object with `dark_mode` as a field, you may summarize\n`settings.dark_mode` but not `settings` nor `settings.*`.\n\nWe currently support several aggregation functions. Not all functions can be run on all column\ntypes.\n\n  - `count` is used to count the number of records in each group. Use `{\"count\": \"*\"}` to count\n    all columns present, otherwise `{\"count\": \"\u003ccolumn_path\u003e\"}` to count the number of non-null\n    values are present at column path.\n\n    Count can be used on any column type, and always returns an int.\n\n  - `min` calculates the minimum value in each group. `min` is compatible with most types;\n    string, multiple, text, email, int, float, and datetime. It returns a value of the same\n    type as operated on. This means that `{\"lowest_latency\": {\"min\": \"latency\"}}` where\n    `latency` is an int, will always return an int.\n\n  - `max` calculates the maximum value in each group. `max` shares the same compatibility as\n    `min`.\n\n  - `sum` adds up all values in a group. `sum` can be run on `int` and `float` types, and will\n    return a value of the same type as requested.\n\n  - `average` averages all values in a group. `average` can be run on `int` and `float` types, and\n    always returns a float.\n","example":{"count":"deleted_at"},"type":"object"},"SummaryExpressionList":{"additionalProperties":{"$ref":"#/components/schemas/SummaryExpression"},"description":"The description of the summaries you wish to receive. Set each key to be the field name\nyou'd like for the summary. These names must not collide with other columns you've\nrequested from `columns`; including implicit requests like `settings.*`.\n\nThe value for each key needs to be an object. This object should contain one key and one \nvalue only. In this object, the key should be set to the summary function you wish to use\nand the value set to the column name to be summarized.\n\nThe column being summarized cannot be an internal column (id, xata.*), nor the base of\nan object, i.e. if `settings` is an object with `dark_mode` as a field, you may summarize\n`settings.dark_mode` but not `settings` nor `settings.*`.\n","example":{"all_users":{"count":"*"},"average_speed":{"average":"speed"},"max_happiness":{"max":"happiness"},"min_cost":{"min":"cost"},"total_created":{"count":"created_at"},"total_revenue":{"sum":"revenue"}},"type":"object"},"Table":{"properties":{"columns":{"items":{"$ref":"#/components/schemas/Column"},"type":"array"},"id":{"type":"string"},"name":{"$ref":"#/components/schemas/TableName"},"revLinks":{"items":{"$ref":"#/components/schemas/RevLink"},"type":"array"}},"required":["name","columns"],"title":"Table","type":"object"},"TableMigration":{"properties":{"modifiedColumns":{"items":{"$ref":"#/components/schemas/ColumnMigration"},"type":"array"},"newColumnOrder":{"items":{"type":"string"},"type":"array"},"newColumns":{"additionalProperties":{"$ref":"#/components/schemas/Column"},"type":"object"},"removedColumns":{"items":{"type":"string"},"type":"array"}},"required":["newColumnOrder"],"title":"TableMigration","type":"object"},"TableName":{"maxLength":255,"minLength":1,"pattern":"[a-zA-Z0-9_\\-~]+","title":"TableName","type":"string"},"TableOpAdd":{"properties":{"table":{"type":"string"}},"required":["table"],"type":"object"},"TableOpRemove":{"properties":{"table":{"type":"string"}},"required":["table"],"type":"object"},"TableOpRename":{"properties":{"newName":{"type":"string"},"oldName":{"type":"string"}},"required":["oldName","newName"],"type":"object"},"TableRename":{"description":"","example":{"newName":"newName","oldName":"oldName"},"properties":{"newName":{"minLength":1,"type":"string"},"oldName":{"minLength":1,"type":"string"}},"required":["newName","oldName"],"type":"object"},"TargetExpression":{"description":"The target expression is used to filter the search results by the target columns.\n","items":{"oneOf":[{"type":"string"},{"additionalProperties":false,"properties":{"column":{"description":"The name of the column.","type":"string"},"weight":{"default":1,"description":"The weight of the column.","maximum":10,"minimum":1,"type":"number"}},"required":["column"],"type":"object"}]},"type":"array"},"TopValuesAgg":{"additionalProperties":false,"description":"Split data into buckets by the unique values in a column. Accepts sub-aggregations for each bucket.\nThe top values as ordered by the number of records (`$count`) are returned.\n","properties":{"aggs":{"$ref":"#/components/schemas/AggExpressionMap"},"column":{"description":"The column to use for bucketing. Accepted types are `string`, `email`, `int`, `float`, or `bool`.","type":"string"},"size":{"default":10,"description":"The maximum number of unique values to return.\n","maximum":1000,"type":"integer"}},"required":["column"]},"TransactionDeleteOp":{"description":"A delete operation. The transaction will continue if no record matches the ID by default. To override this behaviour, set failIfMissing to true.","properties":{"columns":{"description":"If set, the call will return the requested fields as part of the response.","items":{"type":"string"},"type":"array"},"failIfMissing":{"description":"If true, the transaction will fail when the record doesn't exist.","type":"boolean"},"id":{"$ref":"#/components/schemas/RecordID"},"table":{"description":"The table name","type":"string"}},"required":["table","id"],"type":"object"},"TransactionError":{"description":"An error message from a failing transaction operation","properties":{"index":{"description":"The index of the failing operation","type":"integer"},"message":{"description":"The error message","type":"string"}},"required":["index","message"],"type":"object"},"TransactionFailure":{"description":"An array of errors, with indices, from the transaction.","properties":{"errors":{"description":"An array of errors from the submitted operations.","items":{"$ref":"#/components/schemas/TransactionError"},"type":"array"},"id":{"description":"The request ID.","type":"string"}},"required":["id","errors"],"type":"object"},"TransactionGetOp":{"description":"Get by id operation.","properties":{"columns":{"description":"If set, the call will return the requested fields as part of the response.","items":{"type":"string"},"type":"array"},"id":{"$ref":"#/components/schemas/RecordID"},"table":{"description":"The table name","type":"string"}},"required":["table","id"],"type":"object"},"TransactionInsertOp":{"description":"Insert operation","properties":{"columns":{"description":"If set, the call will return the requested fields as part of the response.","items":{"type":"string"},"type":"array"},"createOnly":{"description":"createOnly is used to change how Xata acts when an explicit ID is set in the `record` key. \n\nIf `createOnly` is set to `true`, Xata will only attempt to insert the record. If there's a conflict, Xata \nwill cancel the transaction. \n\nIf `createOnly` is set to `false`, Xata will attempt to insert the record. If there's no\nconflict, the record is inserted. If there is a conflict, Xata will replace the record.\n","type":"boolean"},"ifVersion":{"description":"The version of the record you expect to be overwriting. Only valid with an\nexplicit ID is also set in the `record` key.\n","type":"integer"},"record":{"additionalProperties":true,"description":"The record to insert. The `id` field is optional; when specified, it will be used as the ID for the record.\n","type":"object"},"table":{"description":"The table name","type":"string"}},"required":["table","record"],"type":"object"},"TransactionOperation":{"description":"A transaction operation","oneOf":[{"properties":{"insert":{"$ref":"#/components/schemas/TransactionInsertOp"}},"required":["insert"],"type":"object"},{"properties":{"update":{"$ref":"#/components/schemas/TransactionUpdateOp"}},"required":["update"],"type":"object"},{"properties":{"delete":{"$ref":"#/components/schemas/TransactionDeleteOp"}},"required":["delete"],"type":"object"},{"properties":{"get":{"$ref":"#/components/schemas/TransactionGetOp"}},"required":["get"],"type":"object"}],"type":"object"},"TransactionResultColumns":{"additionalProperties":true,"description":"Fields to return in the transaction result.","type":"object"},"TransactionResultDelete":{"description":"A result from a delete operation.","properties":{"columns":{"$ref":"#/components/schemas/TransactionResultColumns"},"operation":{"description":"The type of operation who's result is being returned.","enum":["delete"],"type":"string"},"rows":{"description":"The number of deleted rows","type":"integer"}},"required":["operation","rows"],"type":"object"},"TransactionResultGet":{"description":"A result from a get operation.","properties":{"columns":{"$ref":"#/components/schemas/TransactionResultColumns"},"operation":{"description":"The type of operation who's result is being returned.","enum":["get"],"type":"string"}},"required":["operation"],"type":"object"},"TransactionResultInsert":{"description":"A result from an insert operation.","properties":{"columns":{"$ref":"#/components/schemas/TransactionResultColumns"},"id":{"$ref":"#/components/schemas/RecordID"},"operation":{"description":"The type of operation who's result is being returned.","enum":["insert"],"type":"string"},"rows":{"description":"The number of affected rows","type":"integer"}},"required":["operation","rows","id"],"type":"object"},"TransactionResultUpdate":{"description":"A result from an update operation.","properties":{"columns":{"$ref":"#/components/schemas/TransactionResultColumns"},"id":{"$ref":"#/components/schemas/RecordID"},"operation":{"description":"The type of operation who's result is being returned.","enum":["update"],"type":"string"},"rows":{"description":"The number of updated rows","type":"integer"}},"required":["operation","rows","id"],"type":"object"},"TransactionSuccess":{"description":"An ordered array of results from the submitted operations.","properties":{"results":{"items":{"oneOf":[{"$ref":"#/components/schemas/TransactionResultInsert"},{"$ref":"#/components/schemas/TransactionResultUpdate"},{"$ref":"#/components/schemas/TransactionResultDelete"},{"$ref":"#/components/schemas/TransactionResultGet"}]},"type":"array"}},"required":["results"],"type":"object"},"TransactionUpdateOp":{"description":"Update operation","properties":{"columns":{"description":"If set, the call will return the requested fields as part of the response.","items":{"type":"string"},"type":"array"},"fields":{"additionalProperties":true,"description":"The fields of the record you'd like to update","type":"object"},"id":{"$ref":"#/components/schemas/RecordID"},"ifVersion":{"description":"The version of the record you expect to be updating","type":"integer"},"table":{"description":"The table name","type":"string"},"upsert":{"description":"Xata will insert this record if it cannot be found.","type":"boolean"}},"required":["table","id","fields"],"type":"object"},"UniqueCountAgg":{"additionalProperties":false,"description":"Count the number of distinct values in a particular column.","properties":{"column":{"description":"The column from where to count the unique values.","type":"string"},"precisionThreshold":{"description":"The threshold under which the unique count is exact. If the number of unique\nvalues in the column is higher than this threshold, the results are approximate.\nMaximum value is 40,000, default value is 3000.\n","type":"integer"}},"required":["column"],"type":"object"},"ValueBooster":{"additionalProperties":false,"description":"Boost records with a particular value for a column.","properties":{"column":{"description":"The column in which to look for the value.","type":"string"},"factor":{"description":"The factor with which to multiply the added boost.","type":"number"},"ifMatchesFilter":{"$ref":"#/components/schemas/FilterExpression","description":"Only apply this booster to the records for which the provided filter matches.\n"},"value":{"description":"The exact value to boost.","oneOf":[{"type":"string"},{"type":"number"},{"type":"boolean"}]}},"required":["column","value","factor"],"type":"object"}},"securitySchemes":{"bearerAuth":{"scheme":"bearer","type":"http"}}},"tags":[{"description":"Database management.","name":"Database","x-displayName":"Database"},{"description":"Branch management.","name":"Branch","x-displayName":"Branch"},{"description":"Branch schema migrations and history.","name":"Migrations","x-displayName":"Migrations"},{"description":"Table management.","name":"Table","x-displayName":"Table"},{"name":"xbregion_other","x-displayName":"other"},{"description":"Record access API.","name":"Records","x-displayName":"Records"},{"description":"APIs for searching, querying, filtering, and aggregating records.","name":"Search and Filter","x-displayName":"Search and Filter"},{"description":"CRUD API for operating on binary content in file and file[] columns.","name":"Files","x-displayName":"Files"},{"name":"xbcell_other","x-displayName":"other"},{"description":"SQL service access","name":"SQL","x-displayName":"SQL"},{"name":"sql_other","x-displayName":"other"}],"x-tagGroups":[{"description":"Xata.io Xatabases API","name":"xbregion","tags":["Database","Branch","Migrations","Table","Migration Requests","xbregion_other"]},{"description":"Xata.io Xatabases API","name":"xbcell","tags":["Records","Search and Filter","Files","xbcell_other"]},{"description":"Xata.io SQL API","name":"sql","tags":["SQL","sql_other"]}]}