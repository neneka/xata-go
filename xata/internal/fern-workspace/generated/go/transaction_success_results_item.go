// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
)

type TransactionSuccessResultsItem struct {
	typeName                string
	TransactionResultInsert *TransactionResultInsert
	TransactionResultUpdate *TransactionResultUpdate
	TransactionResultDelete *TransactionResultDelete
	TransactionResultGet    *TransactionResultGet
}

func NewTransactionSuccessResultsItemFromTransactionResultInsert(value *TransactionResultInsert) *TransactionSuccessResultsItem {
	return &TransactionSuccessResultsItem{typeName: "transactionResultInsert", TransactionResultInsert: value}
}

func NewTransactionSuccessResultsItemFromTransactionResultUpdate(value *TransactionResultUpdate) *TransactionSuccessResultsItem {
	return &TransactionSuccessResultsItem{typeName: "transactionResultUpdate", TransactionResultUpdate: value}
}

func NewTransactionSuccessResultsItemFromTransactionResultDelete(value *TransactionResultDelete) *TransactionSuccessResultsItem {
	return &TransactionSuccessResultsItem{typeName: "transactionResultDelete", TransactionResultDelete: value}
}

func NewTransactionSuccessResultsItemFromTransactionResultGet(value *TransactionResultGet) *TransactionSuccessResultsItem {
	return &TransactionSuccessResultsItem{typeName: "transactionResultGet", TransactionResultGet: value}
}

func (t *TransactionSuccessResultsItem) UnmarshalJSON(data []byte) error {
	valueTransactionResultInsert := new(TransactionResultInsert)
	if err := json.Unmarshal(data, &valueTransactionResultInsert); err == nil {
		t.typeName = "transactionResultInsert"
		t.TransactionResultInsert = valueTransactionResultInsert
		return nil
	}
	valueTransactionResultUpdate := new(TransactionResultUpdate)
	if err := json.Unmarshal(data, &valueTransactionResultUpdate); err == nil {
		t.typeName = "transactionResultUpdate"
		t.TransactionResultUpdate = valueTransactionResultUpdate
		return nil
	}
	valueTransactionResultDelete := new(TransactionResultDelete)
	if err := json.Unmarshal(data, &valueTransactionResultDelete); err == nil {
		t.typeName = "transactionResultDelete"
		t.TransactionResultDelete = valueTransactionResultDelete
		return nil
	}
	valueTransactionResultGet := new(TransactionResultGet)
	if err := json.Unmarshal(data, &valueTransactionResultGet); err == nil {
		t.typeName = "transactionResultGet"
		t.TransactionResultGet = valueTransactionResultGet
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransactionSuccessResultsItem) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transactionResultInsert":
		return json.Marshal(t.TransactionResultInsert)
	case "transactionResultUpdate":
		return json.Marshal(t.TransactionResultUpdate)
	case "transactionResultDelete":
		return json.Marshal(t.TransactionResultDelete)
	case "transactionResultGet":
		return json.Marshal(t.TransactionResultGet)
	}
}

type TransactionSuccessResultsItemVisitor interface {
	VisitTransactionResultInsert(*TransactionResultInsert) error
	VisitTransactionResultUpdate(*TransactionResultUpdate) error
	VisitTransactionResultDelete(*TransactionResultDelete) error
	VisitTransactionResultGet(*TransactionResultGet) error
}

func (t *TransactionSuccessResultsItem) Accept(v TransactionSuccessResultsItemVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transactionResultInsert":
		return v.VisitTransactionResultInsert(t.TransactionResultInsert)
	case "transactionResultUpdate":
		return v.VisitTransactionResultUpdate(t.TransactionResultUpdate)
	case "transactionResultDelete":
		return v.VisitTransactionResultDelete(t.TransactionResultDelete)
	case "transactionResultGet":
		return v.VisitTransactionResultGet(t.TransactionResultGet)
	}
}
